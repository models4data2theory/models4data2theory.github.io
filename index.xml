<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Integrating Theory and Data in Plant-Pollinator Interactions</title>
    <link>https://models4data2theory.github.io/</link>
      <atom:link href="https://models4data2theory.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Integrating Theory and Data in Plant-Pollinator Interactions</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Fri, 23 Aug 2024 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://models4data2theory.github.io/media/icon_hu0409958f157fc50d4e355b357a277bb5_195869_512x512_fill_lanczos_center_3.png</url>
      <title>Integrating Theory and Data in Plant-Pollinator Interactions</title>
      <link>https://models4data2theory.github.io/</link>
    </image>
    
    <item>
      <title>Networks</title>
      <link>https://models4data2theory.github.io/courses/wkshp_networks/</link>
      <pubDate>Thu, 22 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://models4data2theory.github.io/courses/wkshp_networks/</guid>
      <description>&lt;script src=&#34;https://models4data2theory.github.io/rmarkdown-libs/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://models4data2theory.github.io/rmarkdown-libs/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://models4data2theory.github.io/rmarkdown-libs/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://models4data2theory.github.io/rmarkdown-libs/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://models4data2theory.github.io/rmarkdown-libs/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://models4data2theory.github.io/rmarkdown-libs/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://models4data2theory.github.io/rmarkdown-libs/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://models4data2theory.github.io/rmarkdown-libs/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://models4data2theory.github.io/rmarkdown-libs/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://models4data2theory.github.io/rmarkdown-libs/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;p&gt;&lt;em&gt;Analysis of structure&lt;/em&gt;&lt;/p&gt;
&lt;!-- ======================================= --&gt;
&lt;!-- Fernanda --&gt;
&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;
&lt;p&gt;Ecological networks offer a powerful approach to comprehensively analyze entire systems comprising hundreds of species and their thousands of interactions. There are almost infinite ways in which hundreds of species can possibly interact. Networks allow to determine the specific, non-random interaction structure that actually occur in nature of those almost infinite possibilities. These networks also allow the study of the interplay between structure and dynamics of complex systems of interacting species, shedding light on how this interplay influences system responses to perturbations.&lt;/p&gt;
&lt;!-- packages --&gt;
&lt;h2 id=&#34;required-r-packages&#34;&gt;Required R-packages&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# PACKAGE LIST:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Packages&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;igraph&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;s&#34;&gt;&amp;#34;tidyverse&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;s&#34;&gt;&amp;#34;knitr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;s&#34;&gt;&amp;#34;kableExtra&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;s&#34;&gt;&amp;#34;evaluate&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;s&#34;&gt;&amp;#34;webexercises&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;s&#34;&gt;&amp;#34;vegan&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;s&#34;&gt;&amp;#34;bipartite&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;s&#34;&gt;&amp;#34;viridis&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;s&#34;&gt;&amp;#34;rmarkdown&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;s&#34;&gt;&amp;#34;gridGraphics&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# LOAD PACKAGES:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;lapply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Packages&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;library&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;character.only&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;TRUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# SUPPRESS UNHELPFUL `dplyr` MESSAGES: &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dplyr.summarise.inform&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;FALSE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# SAVE PACKAGE WARNING MESSAGES&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# this saves messages associated with package loading; display at the end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# `evaluate` package&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;pkg.load.msgs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;evaluate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lapply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Packages&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;library&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;character.only&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;terminology&#34;&gt;Terminology&lt;/h2&gt;
&lt;p&gt;A network consists of nodes and edges, where &lt;em&gt;nodes&lt;/em&gt; represent discrete entities like people, computers, cities, or species, and &lt;em&gt;edges (or links)&lt;/em&gt; represent the connections between these entities. Networks can be weighted or unweighted, depending on whether the connections have associated values or not. In &lt;em&gt;weighted&lt;/em&gt; networks, the edges have numerical values that indicate the strength or distance of the connection between nodes. In the case of plant-pollinator networks, that weight has traditionally been the number or fraction of visits or pollen transported.&lt;/p&gt;
&lt;p&gt;Networks can also be directed or undirected. In &lt;em&gt;directed&lt;/em&gt; networks, such as food webs, the connections between nodes have a specific direction, such as the flow of energy, indicating a one-way relationship. In &lt;em&gt;undirected&lt;/em&gt; networks, such as mutualistic networks, the connections are bidirectional, showing a two-way relationship between nodes (i.e., reciprocal benefits). We will see later that the reciprocal benefits between plant and pollinator species can be decomposed into the mechanisms by which those benefits are provided, which can convert the bidirectional links between species into two unidirectional links (i.e., consumption of floral rewards and pollination services).&lt;/p&gt;
&lt;p&gt;Networks can also be unipartite or bipartite. &lt;em&gt;Unipartite&lt;/em&gt; networks such as food webs consist of a single set of nodes (species), where edges can connect any pair of nodes within that set (any species can potentially be eaten by others). On the other hand, nodes in &lt;em&gt;bipartite&lt;/em&gt; networks are divided into two disjoint sets, such as plants and pollinators, and edges (representing which pollinator species visits which plant species) only connect nodes from different sets (e.g., plants cannot visit other plants).&lt;/p&gt;
&lt;p&gt;Below, there is an illustration of a plant-pollinator system represented as a bipartite network, with three plant and three pollinator species.&lt;/p&gt;
&lt;img src=&#34;../images/networks/bipartite_network.png&#34; width=&#34;20%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;
&lt;p&gt;Ecological networks can be represented in various ways including a graph (as shown in the image above) or a matrix. Being able to switch between graph (network) and matrix form is powerful for understanding the full suite of network metrics we will see later.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1.1&lt;/strong&gt;: Using the bipartite network graph above, draw the corresponding matrix for the network. Assume that matrix rows represent animal species while matrix columns represent plant species. In the matrix cells, use 1&amp;rsquo;s to indicate an interaction between that animal and plant species and 0&amp;rsquo;s or blanks to indicate no interaction between species.&lt;/p&gt;
&lt;!-- Fernanda section ends here--&gt;
&lt;!-- ======================================= --&gt;
&lt;!-- ======================================= --&gt;
&lt;!-- Berry --&gt;
&lt;h2 id=&#34;network-data&#34;&gt;Network data&lt;/h2&gt;
&lt;p&gt;This workshop is focused on the &lt;em&gt;integration&lt;/em&gt; of empirical data and theory in pollination networks. An important first step toward that integration is to know how to take empirical data and convert them into the standardized matrix format that is used in most packages and functions. For mutualistic networks like plant-pollinator networks, as discussed above, that format is a &lt;em&gt;bipartite&lt;/em&gt; matrix with plants as rows, pollinators as columns, and (typically) counts of interactions filling the matrix.&lt;/p&gt;
&lt;p&gt;Typically, empirical data collected on ecological networks take the form of an &lt;strong&gt;edge list&lt;/strong&gt;. This is the case for pollination networks in particular. To collect pollination network data, we are typically observing a set of flowers. When a flower visitor (presumed pollinator) visits a plant, we would record on a data sheet or field notebook the identity of the plant species and the identity of the flower visitor species. (In the field, we might capture an insect pollinator for later identification, but the idea remains the same, that at some point we would have a data sheet with the identities of the plants and the pollinators).&lt;/p&gt;
&lt;p&gt;Similarly, you could also have an edge list created through pollen DNA metabarcoding; while you might need to play around with the formatting a bit it is common to end up with an edge list like you would have from field data collection.&lt;/p&gt;
&lt;p&gt;That might look something like this:&lt;/p&gt;
&lt;table class=&#34;table table-condensed&#34; style=&#34;color: black; width: auto !important; &#34;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; id.num &lt;/th&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; plant &lt;/th&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; pollinator &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2371 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Delphinium barbeyi &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Bombus flavifrons &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2372 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Heracleum spondophyllum &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Thricops sp. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2373 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Mertensia fusiformis &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Bombus flavifrons &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2374 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Delphinium barbeyi &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Bombus appositus &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2375 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Delphinium barbeyi &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Bombus flavifrons &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2376 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Mertensia fusiformis &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Colias sp. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2377 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Delphinium barbeyi &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Bombus flavifrons &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;hellip; but we want to turn that into a bipartite matrix. One approach for coding that transformation is in the code chunk below, focused on the &lt;code&gt;tidyverse&lt;/code&gt; way of doing things. The general approach is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;group&lt;/em&gt; our data by plant species and pollinator species&lt;/li&gt;
&lt;li&gt;tally the number of visits for each pollinator species that plant species&amp;mdash;basically &amp;ldquo;collapsing&amp;rdquo; the rows that have the same plant-pollinator combinations and counting up how many interactions there were for each unique plant-pollinator combination&lt;/li&gt;
&lt;li&gt;keeping the plants as rows, use the &lt;code&gt;pivot_wider&lt;/code&gt; function in &lt;code&gt;dplyr&lt;/code&gt; (part of the &lt;code&gt;tidyverse&lt;/code&gt;) to create a new column for each pollinator species, filling in for each plant-pollinator combination the number of interactions we calculated in the prior step
&lt;ul&gt;
&lt;li&gt;in doing this step, we are also &amp;ldquo;collapsing&amp;rdquo; all of the plant rows such that there will be one row per plant&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let&amp;rsquo;s see this in action. We&amp;rsquo;ll start with the data frame called &lt;code&gt;edgelist&lt;/code&gt; which is exactly the same as the data in the table above. For the first two steps, here is how we do that, and what it looks like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# step 1:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;weighted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;edgelist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&amp;gt;%&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;group_by&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;plant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pollinator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&amp;gt;%&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# step 2:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;tally&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# show in nicely-formatted table:  &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;kable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;weighted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;row.names&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&amp;gt;%&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;kable_styling&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;full_width&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;left&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bootstrap_options&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;condensed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table class=&#34;table table-condensed&#34; style=&#34;color: black; width: auto !important; &#34;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; plant &lt;/th&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; pollinator &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; n &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Delphinium barbeyi &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Bombus appositus &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Delphinium barbeyi &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Bombus flavifrons &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Heracleum spondophyllum &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Thricops sp. &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Mertensia fusiformis &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Bombus flavifrons &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Mertensia fusiformis &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Colias sp. &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;the new &lt;code&gt;weighted&lt;/code&gt; dataframe is displayed above. You&amp;rsquo;ll see that it created a new column called &amp;ldquo;&lt;strong&gt;n&lt;/strong&gt;&amp;rdquo; that contains the tallied the number of times each unique interaction occurred. It also &amp;ldquo;collapsed&amp;rdquo; the rows into unique plant-pollinator interactions; previously there were 7 rows, and now there are 5, because one of the unique interactions (between &lt;em&gt;Bombus flavifrons&lt;/em&gt; and &lt;em&gt;Delphinium barbeyi&lt;/em&gt;) happened three times.&lt;/p&gt;
&lt;p&gt;Moving from this, let&amp;rsquo;s check out the next step, where where using the &lt;code&gt;pivot_wider&lt;/code&gt; function we pivot the single &amp;ldquo;pollinator&amp;rdquo; column to form one new column for each unique entry in the old column. We will fill in the values for each row-by-column combination from the tallied interactions (the new &amp;ldquo;&lt;strong&gt;n&lt;/strong&gt;&amp;rdquo; column).&lt;/p&gt;
&lt;p&gt;Again there are 5 rows in this new matrix, with 4 unique values (&lt;em&gt;Bombus flavifrons&lt;/em&gt; is represented twice), so we expect to see four pollinator columns emerge in the next step. Similarly, this should collapse the 5 current plant rows into 3, one for each unique plant species. So we should see a 3 row $\times$ 4 column bipartite matrix when we are done.&lt;/p&gt;
&lt;p&gt;This is how to get there:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;bipart.net&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weighted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&amp;gt;%&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;pivot_wider&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id_cols&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;plant&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# plants are the rows&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;names_from&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pollinator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# names of new columns: unique pollinators&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;values_from&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# values in the matrix from tallied interactions&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;values_fill&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# if no value, enter zero (otherwise NA)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# show in nicely-formatted table:  &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;kable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bipart.net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;row.names&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&amp;gt;%&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;kable_styling&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;full_width&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;left&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bootstrap_options&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;condensed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table class=&#34;table table-condensed&#34; style=&#34;color: black; width: auto !important; &#34;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; plant &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Bombus appositus &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Bombus flavifrons &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Thricops sp. &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Colias sp. &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Delphinium barbeyi &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Heracleum spondophyllum &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Mertensia fusiformis &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;looks just as hoped for: a 3-row by 4-column matrix. Note in the code above that we specified that &lt;code&gt;values_fill = 0&lt;/code&gt;. We did this because otherwise &lt;code&gt;R&lt;/code&gt; would not know how to fill in the combinations for which it doesn&amp;rsquo;t have any information, and so it would fill them in with &lt;code&gt;NA&lt;/code&gt; if we left that argument out.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;exercise 1.2:&lt;/strong&gt; Edge List to bipartite network&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s practice turning an edge list into a bipartite network; this time we will do it at a (slightly) larger scale. We are going to use data collected by Berry&amp;rsquo;s Community Ecology class at the University of Washington in spring 2022, at the UW Medicinal Plant Garden (just outside the Life Sciences Building, where the Brosi Lab is based). The data for pollinators were collected at the family level.&lt;/p&gt;
&lt;p&gt;the data file is called &lt;code&gt;medgarden.csv&lt;/code&gt;. Import it and follow the steps above to generate a bipartite network. Call the resulting dataframe &lt;strong&gt;&lt;code&gt;bipartite.med&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;You should get this bipartite network back:&lt;/p&gt;
&lt;table class=&#34;table table-condensed&#34; style=&#34;color: black; width: auto !important; &#34;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; plant &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Osmia &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Bombus &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Syrphid &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Halictid &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Muscid &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Ant &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Hummingbird &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Borago officinalis &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Camassia leichtlinii &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Catharanthus roseus &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Coclearia afficinalis &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Eriogonum umbellatum &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Erysimum asperum &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Gilia capitata &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Glaucium flavum &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Helleborus orientalis &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Heuchera micrantha &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Heuchera sanguinea &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Horminum pyrenaicum &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Hydrophyllum virginiana &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Iris douglasiana &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Polemonium reptans &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Polygonum bisorta &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Rhodiola rosea &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Ruta graveolens &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Sedua spathulifolium &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Smilacina stellata &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Thymus leucospermus &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Tragopogon porrifolius &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Wyethia angustifolia &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 6 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;visualization&#34;&gt;Visualization&lt;/h2&gt;
&lt;!-- 1.1.2 BB: visualizing networks; packing matrices as a means of standardizing their display etc. --&gt;
&lt;p&gt;At the beginning of our materials we covered the two basic ways of visualizing networks, through network diagrams (which show links as lines between nodes) and in matrix format (where each node is a row and/or a column). While understanding those two basic formats is foundationally important for working with networks, visualization is a large and complex topic. Here, we will cover just two additional facets: 1) depicting unipartite networks with &lt;em&gt;adjacency matrices&lt;/em&gt;&amp;mdash;and why that can actually be useful for bipartite networks too&amp;mdash;and 2) how to &lt;em&gt;standardize&lt;/em&gt; matrix depictions of networks, with a focus on bipartite matrices.&lt;/p&gt;
&lt;h3 id=&#34;adjacency-matrices&#34;&gt;Adjacency matrices&lt;/h3&gt;
&lt;p&gt;As we noted above, depending on the type of interaction we are focused on, some networks such as food webs can be considered &lt;em&gt;unipartite&lt;/em&gt;, or in other words any node can potentially interact with any other node in the network. This makes sense for food webs because many species can be predators to some species, but prey to others (especially if we think about different life stages&amp;mdash;a large predatory fish species can be prey to much smaller fish species when it is a juvenile or even an egg).&lt;/p&gt;
&lt;p&gt;Because we are focused on pollination networks in this workshop, so far we have maintained a focus on &lt;em&gt;bipartite&lt;/em&gt; networks, in other words networks where a given node &lt;em&gt;cannot&lt;/em&gt; interact with any other node in the network, but instead can only interact with nodes from the other group or guild. In other words, two different pollinator species can&amp;rsquo;t pollinate one another&amp;mdash;pollination interactions can only occur between one plant and one pollinator.&lt;/p&gt;
&lt;p&gt;Bipartite networks are more intuitive to depict in matrix form relative to unipartite networks. As above, we set one group or guild as the rows of the matrix, and the other group or guild as the columns. But how do we do this for unipartite networks? The answer is what we can an &lt;em&gt;adjacency matrix&lt;/em&gt;, in which each node is included as &lt;em&gt;both&lt;/em&gt; a row and a column.&lt;/p&gt;
&lt;p&gt;To see what this looks like, we will use a food web dataset from the Baltic Sea, from this publication:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Kortsch, S., Frelat, R., Pecuchet, L., Olivier, P., Putnis, I., Bonsdorff, E., Ojaveer, H., Jurgensone, I., Strāķe, S., Rubene, G., Krūze, Ē., and Nordström, M. C. (2021). Disentangling temporal food web dynamics facilitates understanding of ecosystem functioning. &lt;em&gt;Journal of Animal Ecology&lt;/em&gt;, 90(5), 1205-1216. DOI 10.1111/1365-2656.13447.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In plotting the adjacency matrix, we have highlighted the primary diagonal&amp;mdash;which represents self-interactions&amp;mdash;in a darker shade. We have done this highlighting to help orient you to the graph; this particular food web dataset does not include cannibalism (when thinking about trophic interactions, cannibalism is the self-interaction!). One thing to consider is that adjacency matrices look very different if the networks are directed vs. undirected. In particular, for undirected networks (those in which any interaction from A to B is the same as from B to A, for example networks of physical connections like roadway networks), the adjacency matrix will always be symmetrical about the primary diagonal. The adjacency matrix below is very much a directed network&amp;mdash;the interaction is &lt;em&gt;very&lt;/em&gt; different for predators vs. prey!&amp;mdash;and thus it is definitely not symmetric about the primary diagonal.&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_networks_files/figure-html/baltic adjacency-1.png&#34; width=&#34;672&#34; /&gt;
&lt;p&gt;At this point, you might be asking yourself: &amp;ldquo;Well, that&amp;rsquo;s cool and everything, but aren&amp;rsquo;t we here to learn about plant-pollinator networks, which are bipartite? Why are we even bothering with these unipartite networks and adjacency matrices?&amp;rdquo; Great question. Again, how we think about networks&amp;mdash;including how we visualize them&amp;mdash;is fundamentally driven by the &lt;strong&gt;type of interaction&lt;/strong&gt; we are focused on. Up until now, we have ultimately been thinking about plant-pollinator interactions at a pretty superficial level, really considering them at the level of whether or not flower visitation occurs (or not) between a plant species and a pollinator species.&lt;/p&gt;
&lt;p&gt;But if we start to take a more nuanced view of pollination, the benefits that a pollinator gets from a particular flower visit are probably almost never the same as the benefits that the plant gets (let&amp;rsquo;s define &amp;ldquo;benefits&amp;rdquo; here in the context of positive impact on population growth). For example, a single bee visit to a flower may transfer enough pollen to fertilize a dozen or more seeds, but to gather enough pollen to feed a single larvae, that bee may have to visit hundreds of flowers. By using an adjacency matrix, we can visualize the lack of symmetry in benefits among interacting partners.&lt;/p&gt;
&lt;p&gt;This becomes even more useful and important when we delve into modeling population dynamics, later on in this workshop. For example, later today we discuss how the structure of networks can impact their stability. The &lt;em&gt;Jacobian&lt;/em&gt; matrix&amp;mdash;which we will cover briefly later in the workshop&amp;mdash;is (roughly) an adjacency matrix whose cell values describe how an incremental change in the population size of any one node will impact the population of another node. So that allows us to understand how a change in the population of one pollinator species might impact the dynamics of another pollinator species&amp;mdash;even if we are not directly tracking interactions between pollinators! The Jacobian also provides us a way to assess local stability in networks. Stay tuned for more on all of that.&lt;/p&gt;
&lt;h3 id=&#34;edge-list&#34;&gt;Edge list&lt;/h3&gt;
&lt;p&gt;We can convert a bipartite plant-pollinator matrix into an adjacency matrix. In practice, doing this isn&amp;rsquo;t very difficult using the &lt;code&gt;igraph&lt;/code&gt; package, but we will skip the details here as this is not typically done with bipartite networks. Still, we will show you the adjacency matrix depiction so you can get a visual handle on it. Here is the &amp;ldquo;medgarden&amp;rdquo; data that you converted from an edge list, shown in an adjacency matrix format:&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_networks_files/figure-html/adjacency from bipartite-1.png&#34; width=&#34;672&#34; /&gt;
&lt;p&gt;What you probably immediately notice is that there is a big blank space in the upper left. That area is blank because it is dedicated to plant-plant interactions (which we didn&amp;rsquo;t record with this dataset). Looking a bit more closely, there is a corresponding blank area in the bottom right of the matrix, for pollinator-pollinator interactions. Thinking about this a bit more, you can see that the adjacency matrix is divided into four quadrants:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a plant-plant quadrant (upper-left, blank)&lt;/li&gt;
&lt;li&gt;a pollinator-plant quadrant (upper-right, some interactions)&lt;/li&gt;
&lt;li&gt;a plant-pollinator quadrant (lower-left, some interactions, the mirror-image or transponse of the upper-right); and&lt;/li&gt;
&lt;li&gt;a pollinator-pollinator quadrant (lower-right, blank)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Again, if we were to plot interaction values other than the presence-absence of flower visits, we could potentially see values in the blank quadrants. For example, if we were plotting effects on fitness, we might have (negative) values between pollinators because of competition for flowers and/or nest sites, and negative values between plant species driven by competition for pollinators, space, water, light, nutrients, etc.&lt;/p&gt;
&lt;p&gt;Finally, as noted above, we notice that the matrix is symmetric about the primary diagonal, because presence or absence of flower visitation is a non-directional interaction. Again, if we recorded the data differently / in some more specific way (e.g. fitness benefits) we could potentially depict this interaction in a directional fashion.&lt;/p&gt;
&lt;h3 id=&#34;matrix-depictions&#34;&gt;Matrix depictions&lt;/h3&gt;
&lt;p&gt;What is the difference between these two matrices?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_networks_files/figure-html/different depictions same matrix-1.png&#34; width=&#34;672&#34; /&gt;&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_networks_files/figure-html/different depictions same matrix-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;They look pretty different, huh? The second one gives off some distressed Jack-O-Lantern vibes&amp;hellip;&lt;/p&gt;
&lt;p&gt;Perhaps surprisingly, these are two different visualizations of the &lt;em&gt;exact same&lt;/em&gt; network! How can that be?&lt;/p&gt;
&lt;p&gt;Ultimately, as long as each interaction is recorded faithfully, we can move around the order of entire rows and entire columns and it is still the same network. If we re-plot the two figures above, including the row and column labels, we can perhaps see that more easily:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_networks_files/figure-html/different depictions same matrix II-1.png&#34; width=&#34;672&#34; /&gt;&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_networks_files/figure-html/different depictions same matrix II-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;With the row and column labels, you can confirm that the integrity of each interaction is maintained through both of these depictions. For example, row $j$ interacts with column 7 in both depictions, and you could hypothetically go through and confirm that for each of the 69 unique interactions in this made-up example (if you were really bored, that is). To get more detailed without having to go interaction-by-interaction, row $a$ interacts with columns 15 through 24, and this is easy to confirm in both graphs; it&amp;rsquo;s just that the column order is different between the two.&lt;/p&gt;
&lt;p&gt;Thinking about this, there is a &lt;em&gt;very&lt;/em&gt; large number of ways that we could depict the same network&amp;hellip; if $R$ were the number of rows and $C$ the number of columns, then we could represent that network in $R! \times C!$ ways. For the example above with 24 rows and 24 columns, that is 24! $\times$ 24!, or more than 3 $\times$ $10^{47}$. or in other words an unfathomably gigantic number of ways. Put another way, for a 100 $\times$ 100 network, this value is too large for R to calculate.&lt;/p&gt;
&lt;p&gt;With so many potential options, we would ideally like to have a way to &lt;em&gt;standardize&lt;/em&gt; how we depict a network in terms of the arrangement of the rows and columns. Thankfully, there is a clear option in this regard (at least when it comes to bipartite networks): we sort the rows and the columns of the matrix by the &lt;em&gt;degree&lt;/em&gt; or number of connections that each node has. We sort such that the most-generalist (highest degree) row is at the top, and the most-generalist column is at the left. This depiction maximizes our ability to detect &lt;em&gt;nestedness&lt;/em&gt; in our networks (more on that in the next section), and some researchers refer to this arrangement as &amp;ldquo;packing&amp;rdquo; a matrix.&lt;/p&gt;
&lt;p&gt;When visualizing bipartite networks as matrices, an easy option is to use the &lt;code&gt;visweb&lt;/code&gt; function in the &lt;code&gt;bipartite&lt;/code&gt; library for R. &lt;code&gt;visweb&lt;/code&gt; includes options for how you display a network. If your network were called &amp;ldquo;myweb&amp;rdquo;, you could call the below to plot the rows and columns in the order they are in the dataset (i.e. no rearrangement):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;visweb(myweb, type = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If you want to standardize (order the rows and columnns by degree / generalization), you can instead use the bipartite default:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;visweb(myweb, type = &amp;quot;nested&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The one caveat here is that &lt;code&gt;bipartite&lt;/code&gt; uses a quick-and-dirty algorithm to get this done that can yield far-from-perfect results, so if you want to make sure that you have truly &amp;ldquo;packed&amp;rdquo; your matrix, you might want to use your own code. It&amp;rsquo;s really not hard; some example code is below (and for aficionados of concise code, it would be straightforward to collapse this down into three lines of code).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;rows&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rowSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# calculate row sums&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cols&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;colSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# calculate column sums&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;roworder&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decreasing&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# order rows by sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;colorder&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cols&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decreasing&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# order columns by sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;mat&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mat[roworder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;colorder]&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# re-order rows and cols in matrix&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, &lt;code&gt;visweb&lt;/code&gt; includes a third option, &amp;ldquo;diagonal&amp;rdquo; arrangement, which maximizes the number of interactions occurring along the diagonal of the bipartite matrix. While a non-standard way to depict matrices, it is helpful for seeing modularity (more on that just below) or compartments in the matrix. You can do that via this command:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;visweb(myweb, type = &amp;quot;diagonal&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1.3&lt;/strong&gt; use the &amp;ldquo;medgarden&amp;rdquo; data you put into matrix form, above&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;plot via &lt;code&gt;visweb&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;with &lt;code&gt;type = &amp;quot;none&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;with &lt;code&gt;type = &amp;quot;nested&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;with &lt;code&gt;type = &amp;quot;diagonal&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;ldquo;pack&amp;rdquo; the matrix using the code included above (or your own variant if you prefer)&lt;/li&gt;
&lt;li&gt;re-plot with &lt;code&gt;type = &amp;quot;none&amp;quot;&lt;/code&gt;; the newly packed data should closely resemble the &lt;code&gt;type = &amp;quot;nested&amp;quot;&lt;/code&gt; network&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- Berry section ends here--&gt;
&lt;!-- ======================================= --&gt;
&lt;h2 id=&#34;metrics-of-structure&#34;&gt;Metrics of structure&lt;/h2&gt;
&lt;!-- ======================================= --&gt;
&lt;!-- Fernanda --&gt;
&lt;p&gt;A useful summary of network metrics and their effect on network robustness to species extinctions can be found in this TedEd video: &lt;a href=&#34;https://www.youtube.com/watch?v=Y5uRVv7GGQM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Valdovinos Ted Ed video&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;connectance&#34;&gt;Connectance&lt;/h3&gt;
&lt;p&gt;Connectance measures the proportion of potential interactions that are realized in the network (&lt;em&gt;i.e.&lt;/em&gt;, the number of different interactions observed as a fraction of the total number of interactions that could possibly occur). Thus, connectance ranges between 0 (no connections between any species) and 1 (every species interacts with every other species). In unipartite networks, connectance is calculated by dividing the number of realized interactions (or links connecting species) $L$ by the square of the number of nodes $S$ in the network, which represents the total number of interactions if all species were fully connected to one another, including themselves. So, $C=L/S^2$. However, in a bipartite network, nodes from different sets cannot interact. Which should be the expression for connectance in a bipartite network?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1.4&lt;/strong&gt;: The denominator of the connectance formula represents the total number of possible interactions in the network, if all species were fully connected to one another. What is the total number of potential interactions in a bipartite network such as a plant-pollinator one?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1.5&lt;/strong&gt;: Calculate the connectance of the bipartite network graph from Exercise 1.1 using the formula you derived in Exercise 1.2.&lt;/p&gt;
&lt;h3 id=&#34;nestedness&#34;&gt;Nestedness&lt;/h3&gt;
&lt;p&gt;In a nested network, the interactions of the more specialized species are subsets of the interactions of the more generalized species. Another way to define nestedness is by saying that generalists tend to interact with both generalists and specialists while specialists tend to interact with mostly generalists. Note that the concept of specialist species in a network context is best interpreted as realized interactions and not necessarily as &amp;ldquo;true specialist&amp;rdquo; in the evolutionary sense. One particular species can be recorded as specialist (i.e., with only one interaction) in a particular day/week/season but then be recorded as a generalist in the next day/week/season.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1.6&lt;/strong&gt;: Run the code chunk below to see two example networks: Network #1 and Network #2. Given the two example networks below, which do you consider to have higher nestedness and why?&lt;/p&gt;
&lt;img src=&#34;../images/networks/compare_nestedness.png&#34; style=&#34;display: block; margin: auto;&#34; /&gt;
&lt;h3 id=&#34;modularity&#34;&gt;Modularity&lt;/h3&gt;
&lt;p&gt;A network is said to have high modularity when its interactions are compartmentalized into modules, whose species interact more among themselves than with species belonging to other modules.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1.7&lt;/strong&gt;: Given the two example networks of Exercise 1.4, which do you consider to have higher modularity and why?&lt;/p&gt;
&lt;!-- Berry  start--&gt;
&lt;h3 id=&#34;calculating-metrics&#34;&gt;Calculating metrics&lt;/h3&gt;
&lt;p&gt;We can calculate network metrics in empirical networks in a relatively straightforward way using the &lt;code&gt;bipartite&lt;/code&gt; package for R. The &lt;code&gt;networklevel()&lt;/code&gt; function calculates a huge number of different network metrics. This is not a function to use to spit out a zillion metrics and cherry-pick which ones look best&amp;mdash;you will instead want to figure out &lt;em&gt;a priori&lt;/em&gt; which metrics you are most interested in, and calculate only those.&lt;/p&gt;
&lt;p&gt;For the &amp;ldquo;Safariland&amp;rdquo; plant-pollinator network dataset that comes included in the &lt;code&gt;bipartite&lt;/code&gt; package, we can calculate nestedness with the NODF metric (there are many other ways to calculate nestedness):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;networklevel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Safariland&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;NODF&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;##    NODF 
## 24.5478
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;easy! We can do the same thing for modularity (note: modularity can take some time to calculate, especially on older / slower computers):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;networklevel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Safariland&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;modularity&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## modularity Q 
##    0.4301558
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Exercise 1.8&lt;/strong&gt;: Use the &amp;ldquo;medgarden&amp;rdquo; data you put into matrix form, above. Calculate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$H_2&amp;rsquo;$ (network-level specialization); in &lt;code&gt;networklevel&lt;/code&gt;, use &lt;code&gt;index = &amp;quot;H2&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;connectance&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- Berry  end--&gt;
&lt;h3 id=&#34;relationships-among-metrics&#34;&gt;Relationships among metrics&lt;/h3&gt;
&lt;p&gt;When analyzing the structure of a specific network and especially when comparing the structure of several networks, for example across a latitudinal or altitudinal gradient, you must keep in mind that all these metrics correlate, some positively others negatively. The best known of those relationships is the negative correlation between network richness (i.e., number of species) and connectance, which is shown in this image below taken from Thebault &amp;amp; Fontaine 2010 (Science), where species richness is labeled as &amp;ldquo;network size&amp;rdquo; and the black dots are mutualistic networks while the red dots are plant-herbivore bipartite networks.&lt;/p&gt;
&lt;img src=&#34;../images/networks/CvsS.bmp&#34; style=&#34;display: block; margin: auto;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1.9&lt;/strong&gt;: Given the mathematical formula of connectance, C = L/(P*A), how would you explain this well-known negative relationship between species richness, S = P+A, and connectance?&lt;/p&gt;
&lt;p&gt;Other known relationships include the positive correlation between connectance and nestedness, the negative correlation between connectance and modularity, the positive correlation between species richness and nestedness, and the negative relationship between species richness and modularity.&lt;/p&gt;
&lt;img src=&#34;../images/networks/path_analysis.PNG&#34; style=&#34;display: block; margin: auto;&#34; /&gt;
&lt;p&gt;Understanding these relationships among network metrics is crucial when analyzing variations across environmental or perturbation gradients in network structure. For instance, if you are investigating how urbanization impacts the network structure of plant-pollinator communities and observe a significant negative impact of urbanization on species richness, caution is needed when comparing other network metrics across the urbanization gradient. This is due to the established relationship between species richness and various network metrics, which could potentially obscure the effect of urbanization by influencing connectance and modularity positively and nestedness negatively. That is, because decreased species richness increases connectance and modularity and decreases nestedness you may infer that it was urbanization which caused those effects on network structure but most likely it is the confounding effect of decreased species richness.&lt;/p&gt;
&lt;p&gt;In the past, we all used $z$-scores to compare network metrics across networks, but there has been recent criticism to using z-scores for that purpose (Song et al 2017, Journal of Animal Ecology). Song et al proposed a new nestedness metric, NODFc, which can be calculated using the R package &amp;ldquo;maxnodf&amp;rdquo; (Hoeppke &amp;amp; Simmons 2021, Methods in Ecology and Evolution) to compare nestedness across networks. Other researchers have used statistical analyses such as generalized linear mixed models to disentangle the effect of a specific treatment from species richness on other network metrics (refs). Covering these recent alternatives and the criticism of using $z$-scores is beyond the scope of this course but it is important that you are aware of these recent developments and, most importantly, that you are aware of the known relationships between network metrics so you consider them when making inferences based on your network analyses.&lt;/p&gt;
&lt;!-- Fernanda section ends here--&gt;
&lt;!-- ======================================= --&gt;
&lt;!-- ======================================= --&gt;
&lt;!-- Berry --&gt;
&lt;!-- 1.2.1 BB: calculating network metrics null models to assess significance of network metrics? Probably do this only for nestedness covering perhaps 2 of the null models? (point them to literature on others?)—be careful of the rabbit hole  --&gt;
&lt;h2 id=&#34;null-models&#34;&gt;Null models&lt;/h2&gt;
&lt;p&gt;In some situations, it is helpful to know if an empirical network exhibits a value of some network metric that is greater than you would expect by chance alone. Nestedness is a good example, because we might actually expect networks to display some level of nestedness just because of some of the basic facts of how they are set up. Most communities display a very skewed distribution of abundances, with one or just a few species having very high abundance, and then a lot of species with low abundances. If we have such an abundance distribution for both guilds (e.g. plant and pollinator species), and plants and pollinators are interacting with one another purely at random, we would expect that rare pollinator species would be most likely to interact with common plant species, and that rare plant species would be most likely visited by common pollinators. This is especially true if we are sampling the network on a per-area basis (in which we would log much more observation time on the most common plants). Taken together, the elements of this scenario&amp;mdash;which with the exception of the random interactions, is pretty much the case in most plant-pollinator networks&amp;mdash;would lead to a very nested pattern.&lt;/p&gt;
&lt;p&gt;Given that, we might ask if a network is more nested than we would expect it to be relative to chance alone. We can do this with &lt;strong&gt;null model&lt;/strong&gt; simulations. What exactly &lt;em&gt;is&lt;/em&gt; a null model? It&amp;rsquo;s a concept that has been surprisingly difficult to pin down, but the definition provided in the book &amp;ldquo;Null Models in Ecology&amp;rdquo; by Nick Gotelli &amp;amp; Gary Graves (1996, Smithsonian Institution Press, Washington, D.C.) is a helpful one:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A null model is a pattern-generating model that is based on randomization of ecological data or random sampling from a known or imagined distribution. The null model is designed with respect to some ecological or evolutionary process of interest. Certain elements of the data are held constant, and others are allowed to vary stochastically to create new assemblage patterns. The randomization is designed to produce a pattern that would be expected in the absence of a particular ecological mechanism.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If we were asking if a network is more nested than we would expect with chance alone, one way to frame that is to say that we don&amp;rsquo;t think interactions are happening randomly between plants and pollinators. Instead, plants and pollinators have traits that structure their interactions; pollinators draw down resource levels in flowers that then affect the preferences of other pollinators, etc. But, we &lt;em&gt;can&lt;/em&gt; create a null model where we assume interactions are happening randomly, repeat that random interaction assignment many times, and then assess if our actual data are different (e.g., more or less nested) than we would expect based on random interactions. The basic statistical idea here is a &lt;em&gt;permutation test&lt;/em&gt;, for those of you familiar with that concept.&lt;/p&gt;
&lt;h3 id=&#34;alternatives&#34;&gt;Alternatives&lt;/h3&gt;
&lt;p&gt;But that sounds pretty complicated (and to be honest, it is not the most straightforward thing ever)&amp;mdash;so how do we actually implement null models in practice? Luckily, the &lt;code&gt;bipartite&lt;/code&gt; package has built-in algorithms to create null models (and there are other R packages that do as well, notably &lt;code&gt;vegan&lt;/code&gt;), so you don&amp;rsquo;t have to code these by hand (phew!). But because there are different kinds of null models, it is critically important to understand what is going on &amp;ldquo;under the hood&amp;rdquo; of the algorithm so that you can apply the right null model to your analysis.&lt;/p&gt;
&lt;h3 id=&#34;simplest-null-model&#34;&gt;Simplest null model&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s start by thinking about the simplest possible way we could create a null model. We want to assume that interactions are happening at random. Perhaps a first-pass way of doing this would be to say something along the lines of &amp;ldquo;well we have our plant species and our pollinator species, i.e. our bipartite matrix, and we recorded a total of $N$ interactions in our empirical data&amp;hellip; all we have to do is randomly assign each interaction to one cell in our bipartite matrix, and we&amp;rsquo;ll end up with a randomized network&amp;rdquo;. That would be one way to do it, but it has some pretty major downsides. One downside is that when you repeat that procedure, especially if your $N$ is relatively small, you are likely to have one or more species that have no interactions and thus would drop out of the network. Because some network metrics are sensitive (sometimes &lt;em&gt;very&lt;/em&gt; sensitive) to network size / species richness, that&amp;rsquo;s definitely not ideal. You could get around that downside, perhaps by first assigning one interaction to each row (a random column in that row), and then assessing if all columns have an interaction, and for any that are missing, assigning a random interaction to that column. Then you could assign all of the &amp;ldquo;leftover&amp;rdquo; interactions randomly as described above.&lt;/p&gt;
&lt;h3 id=&#34;constant-link-number&#34;&gt;Constant link number&lt;/h3&gt;
&lt;p&gt;Making sure the species richness stays constant is an important improvement over the first-pass method, but the sketch of a null model described above still ultimately has some problems. One key reason is that while the number of total &lt;em&gt;interactions&lt;/em&gt; is maintained, the sketch of the algorithm described above does not maintain the same number of &lt;em&gt;links&lt;/em&gt; in the network. Given a wide-open matrix in which to assign interactions, in particular such an algorithm will typically generate many more links than we would see in an empirical dataset, and that is also definitely not ideal. A &amp;ldquo;second-pass&amp;rdquo; null model would maintain the same number of interactions (as we suggested in the &amp;ldquo;first-pass&amp;rdquo; model), but would also maintain the number of links (and therefore hold &lt;em&gt;connectance&lt;/em&gt; constant). This is what the &lt;code&gt;shuffle.web&lt;/code&gt; algorithm in the &lt;code&gt;bipartite&lt;/code&gt; package does. This is an algorithm that has been used in some papers, e.g. Fortuna, M. A., and J. Bascompte. 2006. Habitat loss and the structure of plant-animal mutualistic networks. &lt;em&gt;Ecology Letters&lt;/em&gt; 9: 281-286.&lt;/p&gt;
&lt;h3 id=&#34;constant-degree&#34;&gt;Constant degree&lt;/h3&gt;
&lt;p&gt;Still, the &lt;code&gt;shuffle.web&lt;/code&gt; null model algorithm is not widely used these days. A major reason is that (again) some plants, and some pollinators, are much more common, and some are rare. And that skewed abundance distribution could be a &lt;em&gt;big&lt;/em&gt; driver of any nestedness we see in a system (as well as potentially other network metrics). To account for that, we can instead implement what we might call a &amp;ldquo;third-pass&amp;rdquo; algorithm that accounts for the empirically-observed number of interactions for each species, and holds those &amp;ldquo;marginal totals&amp;rdquo; constant. In practice, this would be straightforward to do for just &lt;em&gt;one&lt;/em&gt; of the guilds in our network&amp;mdash;let&amp;rsquo;s say we do it for plants. We can take the total number of interactions for each plant species, and assign them randomly across the pollinators in the network. Easy-peasy. The problem is that we are trying to do this also at the same time for pollinators, and that is a lot trickier! Again, luckily we don&amp;rsquo;t have to code this by hand. This null model is implemented in the &lt;code&gt;r2dtable&lt;/code&gt; function in &lt;code&gt;bipartite&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;constant-link-number-and-degree&#34;&gt;Constant link number and degree&lt;/h3&gt;
&lt;p&gt;Taking our exploratino of null models yet another step further, &lt;code&gt;r2dtable&lt;/code&gt; is very helpful in terms of accounting for the number of interactions that each species has. But accounting just for that does not necessarily give us the same number of &lt;em&gt;links&lt;/em&gt; (or put another way, &lt;em&gt;connectance&lt;/em&gt;) displayed by our data, as we described above. So a &amp;ldquo;fourth-pass&amp;rdquo; algorithm would hold multiple components constant relative to the empirical data: 1) the total number of interactions in the whole network; 2) the total number of interactions for each plant and pollinator species; and 3) the number of links / network connectance. This is (at least theoretically) implemented in the &lt;code&gt;swap.web&lt;/code&gt; function in &lt;code&gt;bipartite&lt;/code&gt; and is a very commonly-used null model. This approach was first implemented in: Miklós, I. and Podani, J. (2004) Randomization of presence-absence matrices: comments and new algorithms. &lt;em&gt;Ecology&lt;/em&gt; 85, 86–92.&lt;/p&gt;
&lt;p&gt;There are other approaches as well, for example the &lt;code&gt;vaznull&lt;/code&gt; function uses an approach proposed by Diego Vázquez et al. in 2007 (&lt;em&gt;Oikos&lt;/em&gt; 116: 1120-1127). This algorithm weights the probability of selecting a cell (interaction) in the matrix by the abundance (number of empirically observed interactions) of both the plant and the pollinator. While similar to the &lt;code&gt;r2dtable&lt;/code&gt; algorithm in that regard, it does not hold the row and column sums to be absolutely constant, even though they are weighted by interaction abundance. The &lt;code&gt;vaznull&lt;/code&gt; algorithm is also supposed to maintain equal or close-to-equal connectance, like &lt;code&gt;swapweb&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;comparing-null-models&#34;&gt;Comparing null models&lt;/h3&gt;
&lt;p&gt;More constrained is not always better.&lt;/p&gt;
&lt;p&gt;Ultimately, however, it&amp;rsquo;s important to understand that every null model has drawbacks. The more things that are held constant, the fewer potential randomizations there are that can be done that meet all of the criteria. For some unusually structured networks (especially for small networks) the number of possible permutations becomes very small for highly constrained algorithms like &lt;code&gt;swap.web&lt;/code&gt;. Moreover, the &lt;code&gt;swap.web&lt;/code&gt; and &lt;code&gt;vaznull&lt;/code&gt; approaches have been criticized for biasing some &amp;ldquo;swaps&amp;rdquo; of interactions (i.e. some swaps are more likely than others, when they shouldn&amp;rsquo;t be). There is to our knowledge no &amp;ldquo;perfect&amp;rdquo; null model implementation but it&amp;rsquo;s also good to know that network null models are also implemented in other packages, notably there are &amp;gt;25 null model algorithms implemented in the &lt;code&gt;vegan&lt;/code&gt; package. To learn more, check out the documentation of the &lt;code&gt;commsim&lt;/code&gt; function: &lt;code&gt;?vegan::commsimm&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;graphical-implementation&#34;&gt;Graphical implementation&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s delve into how to use these algorithms in practice, starting by graphically implementing a null model analysis (we discuss how to calculate a $p$-value for this procedure below). For this graphical analysis, we&amp;rsquo;ll focus on NODF (again, a metric of nestedness) in the &amp;ldquo;Safariland&amp;rdquo; plant-pollinator network dataset that is included in the &lt;code&gt;bipartite&lt;/code&gt; package (code below altered slightly from Carsten Dormann&amp;rsquo;s &lt;code&gt;bipartite&lt;/code&gt; vignette). We will use the &lt;code&gt;swap.web&lt;/code&gt; algorithm and create 999 null networks to compare with the empirical &amp;ldquo;Safariland&amp;rdquo; dataset. We will plot the NODF value of the empirical dataset as a red vertical line, and display the distribution of the null networks with a density plot (we could just as easily display it as a histogram as an alternative, code included but commented out). Here is the code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Safariland&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Iobs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;networklevel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Safariland&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;NODF&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;[[1]]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;nulls&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;nullmodel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;web&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Safariland&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;999&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#39;swap.web&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# can take a while...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Inulls&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sapply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nulls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;nestednodf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;statistic[3]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;plot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;density&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Inulls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xlim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lwd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;NODF&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# plot(hist(Inulls), xlim=c(0, 100), lwd=2, main=&amp;#34;NODF&amp;#34;) # histogram&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;abline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Iobs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;col&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;red&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lwd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_networks_files/figure-html/null model NODF-1.png&#34; width=&#34;672&#34; /&gt;
&lt;p&gt;What we see is that the NODF (nestedness) value of the empirical dataset&amp;mdash;the red line&amp;mdash;is somewhere in the middle of the distribution of the null-model NODF scores. That is, our empirical value would likely not be considered either more or less nested than chance alone.&lt;/p&gt;
&lt;h3 id=&#34;checking-results&#34;&gt;Checking results&lt;/h3&gt;
&lt;p&gt;Before we get to $p$-values, it is always worth checking if the null model we are using actually has the properties that we want. Relative to the empirical network, the &lt;code&gt;swap.web&lt;/code&gt; algorithm is supposed to: 1) maintain the connectance; and 2) maintain the row and column sums. Let&amp;rsquo;s check that it is actually doing that. We&amp;rsquo;ll calculate the mean and standard deviation of connectance across all 999 networks; we should be getting an exact or very close to exact match with our empirical connectance, and a standard deviation that is either zero (meaning all of the null networks have the exact same connectance) or very very small. We can then compare the row and column sums.&lt;/p&gt;
&lt;p&gt;we&amp;rsquo;ll start with connectance:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# calculate connectance across the null networks&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Cnulls&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sapply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nulls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;networklevel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;connectance&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;[1]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Cempirical&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;networklevel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Safariland&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;connectance&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;[1]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;SDnulls&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Cnulls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## mean connectance of null networks = 0.1604938
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## connectance of empirical network = 0.1604938
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## standard deviation of null networks = 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Looks great: connectance is exactly the same between the two, and the standard deviation in connectance in the null networks is zero, meaning that each and every null network has the exact same connectance as our empirical network.&lt;/p&gt;
&lt;p&gt;Still, it is worth trying this, because sometimes&amp;mdash;even in recent versions of &lt;code&gt;bipartite&lt;/code&gt;&amp;mdash;we have had the experience where these null models do not perform exactly as expected. In those cases, usually if we start a new R session and re-try, it works&amp;hellip; but again, it is definitely worth checking.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s check the species degrees (row and column sums). This one is just a little trickier, because there is one value for &lt;em&gt;each species&lt;/em&gt; in the network, not just one numeric value for the entire network (as there was with connectance). To account for that, we will put the values&amp;mdash;for both the row and the column sums&amp;mdash;into a data frame, with rows as species and a column for each of the empirical data and the means of the null models. A nice way to check this formally is then to subtract those two columns; if they are exactly the same (as they should be), then the difference for each value would be zero.&lt;/p&gt;
&lt;p&gt;We will do the procedure for both the pollinators and the plants, but we will just display the results in tabular form for the 9 plant species in the &amp;ldquo;Safariland&amp;rdquo; dataset to save space.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# calculate row sums across the null networks&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Rsums.nulls&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sapply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nulls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rowSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# this returns a 9 x 999 matrix, with one column for each null model&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# now take the mean across all of those row sums:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Rsums.mean&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;apply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Rsums.nulls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MARGIN&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FUN&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# we&amp;#39;ll put this into a data frame along with the empirical row sums:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;comper&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;data.frame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empirical&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rowSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Safariland&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Rsums.mean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# we will check that out in just a second, but first we&amp;#39;ll add the col sums:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Csums.nulls&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sapply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nulls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;colSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Csums.mean&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;apply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Csums.nulls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MARGIN&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FUN&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;comper2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;data.frame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empirical&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;colSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Safariland&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Csums.mean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# bid row &amp;amp; col sum dataframes together:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;comper&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rbind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;comper&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;comper2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# subtract null values from empirical values &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# (all should be zero if algorithm performing correctly)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;comper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;difference&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;comper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empirical&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;comper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;null&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# display&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;kable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;comper[1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;row.names&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&amp;gt;%&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;kable_styling&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;full_width&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;left&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bootstrap_options&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;condensed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table class=&#34;table table-condensed&#34; style=&#34;color: black; width: auto !important; &#34;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt;  &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; empirical &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; null &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; difference &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Aristotelia chilensis &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 790 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 790 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Alstroemeria aurea &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 208 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 208 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Schinus patagonicus &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 15 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 15 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Berberis darwinii &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 72 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 72 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Rosa eglanteria &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 15 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 15 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Cynanchum diemii &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 20 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 20 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Ribes magellanicum &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 5 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 5 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Mutisia decurrens &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Calceolaria crenatiflora &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Looks great&amp;mdash;all of the row sums (plant degrees) are the same between the null models and the empirical network. Again, the code above included all of the column sums (pollinator degrees), as well as a column for difference between empirical row/column sums and mean null model row/col sums. We could easily assess if there were any departures from zero with this line of code: &lt;code&gt;which(comper$difference!=0)&lt;/code&gt;. If it returns &lt;code&gt;integer(0)&lt;/code&gt; you know that they match perfectly (in this case, they do).&lt;/p&gt;
&lt;p&gt;Of course, we didn&amp;rsquo;t check out the standard deviations here, so there is a small chance that there is some variation across the null models (but a pretty tiny chance indeed, given that we see integers for all of the mean values&amp;hellip;) but that is something that would be easy to add to the code above if you were interested.&lt;/p&gt;
&lt;p&gt;Bringing this back full circle, that means that the &lt;code&gt;swap.web&lt;/code&gt; algorithm is doing what we expected relative to the empirical data:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maintaining the same connectance&lt;/li&gt;
&lt;li&gt;maintaining the same row and column sums&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;while we didn&amp;rsquo;t do an explicit check to see if the total number of interactions is the same between the two, we couldn&amp;rsquo;t maintain the same row and column sums and also have a different total number of interactions, so we are safe there as well.&lt;/p&gt;
&lt;h3 id=&#34;significance&#34;&gt;Significance&lt;/h3&gt;
&lt;p&gt;Our first pass at the null model analysis above was graphical. We can formalize this test in a very straightforward way, calculating a $p$-value by assessing the &lt;em&gt;rank&lt;/em&gt; of the empirical value relative to the nulls. Let&amp;rsquo;s imagine a case in which the empirical value was more-nested than almost all of the nulls. If we were to generate 99 nulls, and out of the 100 total networks we were assessing (the 99 nulls + the 1 empirical network), the empirical network was the 5th-most nested (i.e. 4 null models were more nested), then the $p$-value would be exactly 0.05 (5 out of 100). One way of conceptualizing that is that if the empirical value was part of the same distribution as our null models, we could assign it a rank in that distribution at random. And there would only be a 5% chance ($p$ = 0.05) that the rank would be 5th or more extreme (4th, 3rd, 2nd, or 1st).&lt;/p&gt;
&lt;p&gt;Similarly, if the empirical network were the most-nested of all, the $p$-value would be 0.01 (1 out of 100). Two lessons from that: first, it makes the $p$-value calculations slightly easier if you generate {some power of 10 minus 1} null models, e.g. 99 or 999 or 9,999 null models. Still, that is not strictly required. And second, the more null models you calculate, the greater the &lt;em&gt;precision&lt;/em&gt; you have in your $p$-value. The examples above were for 99 null models; if you were to use 9,999 nulls and your empirical network were the top-ranked one, the $p$-value would be 0.0001 (1 in 10,000). The caveat there is that the more null models you calculate, the longer it takes. Typically if you&amp;rsquo;re after assessing statistical significance in the traditional sense, you will want to use more than 99 null models, as that is pretty coarse, especially since you can have slight variations in the $p$-value if you re-run your null models. Still, once you get to 999 you should (usually) know if the $p$-value is less than the standard $\alpha$ value of 0.05. If you have a borderline value, you might want to amp up the resolution by running more null models.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s also worth noting that the $p$-values as described above are for a one-tailed test. For example, if you had the &lt;em&gt;a priori&lt;/em&gt; hypothesis that your empirical network was &lt;em&gt;more&lt;/em&gt; nested than you would expect by chance, then you could assess that with a one-tailed test. If you wanted to see if your network was &lt;em&gt;either&lt;/em&gt; more or less nested than chance alone, for the example with 99 null models, if your empirical data were either the most or the least nested, there is a 1 in 100 chance of &lt;em&gt;either&lt;/em&gt; of those situations happening. So you would need to multiply the $p$-value by 2 to compensate: there is a 2 in 100 chance of either occurring, so the $p$-value for either situation would be not 0.01, but 0.02.&lt;/p&gt;
&lt;h4 id=&#34;p-value-calculation&#34;&gt;p-value calculation&lt;/h4&gt;
&lt;p&gt;With all of that in place, we can write code to calculate the (two-tailed) $p$-value. A few things to note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;we use &lt;code&gt;length(which())&lt;/code&gt; to assess rank, by seeing how many null values are more-extreme than our empirical value&lt;/li&gt;
&lt;li&gt;to properly assess the rank of the empirical data, we add 1 to the result of &lt;code&gt;length(which())&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;if there were say 11 null values that were smaller, the rank of the empirical data would then be 12th (not 11th)&lt;/li&gt;
&lt;li&gt;adding 1 also corrects the situation where the empirical value is the most-extreme, i.e. zero null values would be less than the empirical value. In that case, we want the p-value to be (say) 0.001 or 0.0001, not 0.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;because this is a two-tailed test, we assess if the rank of the empirical value is greater than &lt;em&gt;or&lt;/em&gt; less than the mean of the null distribution (using &lt;code&gt;min&lt;/code&gt; below)&lt;/li&gt;
&lt;li&gt;again because of the two-tailed nature of the test, we multiply the value by 2 at the end&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# two-tailed p-value for permutation test with null models&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;pval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;which&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Inulls&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Iobs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;which&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Iobs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Inulls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;+1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nf&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Iobs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Inulls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## p = 0.402
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, we can see that the $p$-value is 0.402, i.e. the Safariland network is not significantly nested relative to chance.&lt;/p&gt;
&lt;h2 id=&#34;take-home&#34;&gt;Take-home&lt;/h2&gt;
&lt;p&gt;Together these examples point to a few take-home messages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the precise null model you use for your analysis matters&amp;mdash;different null models can give you completely different results&lt;/li&gt;
&lt;li&gt;in general, a good default is to use a more conservative null model algorithm, i.e. one that holds constant more features of the empirical network
&lt;ul&gt;
&lt;li&gt;but be careful especially with small networks that your null models are not too constrained to generate substantive enough variation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;always check your null models to make sure they are performing as expected&lt;/li&gt;
&lt;li&gt;use a two-tailed $p$-value as a default, unless you have laid out an &lt;em&gt;a priori&lt;/em&gt; hypothesis that includes directionality (e.g., &amp;ldquo;I hypothesize that this network will be less-nested than chance alone would predict&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1.10:&lt;/strong&gt; Analyze NODF for the &amp;ldquo;Safariland&amp;rdquo; dataset using the &lt;code&gt;r2dtable&lt;/code&gt; null model, 1) graphically and 2) by calculating the (two-tailed) $p$-value. You should get a qualitatively different result relative to using &lt;code&gt;swap.web&lt;/code&gt;. Desribe where the empirical value falls out relative to the null models. &lt;strong&gt;BONUS:&lt;/strong&gt; using the information above on the correlation among network metrics, as well as descriptions of the null models, offer an interpretation as to &lt;em&gt;why&lt;/em&gt; the two null models yield qualitatively different results.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DOUBLE BONUS:&lt;/strong&gt; try one of the null models implemented in &lt;code&gt;vegan&lt;/code&gt;, in particular &lt;code&gt;quasiswap_count&lt;/code&gt;. Here is some code that should help you; the syntax is different for the &lt;code&gt;vegan&lt;/code&gt; implementation relative to &lt;code&gt;bipartite&lt;/code&gt; and in addition &lt;code&gt;vegan&lt;/code&gt; returns the null models not as a list, but instead as a 3-dimensional array. The latter means you need to take a slightly different approach when calculating NODF (or any other metric) across the null models.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# alternative: use vegan::nullmodel rather than bipartite&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# require first setting up a null model, then separately simulating it&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;n.vegan&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vegan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;nullmodel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Safariland&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;quasiswap_count&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;#setup&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;nulls.vegan&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simulate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n.vegan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nsim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;999&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;#simulation&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# the vegan `simulate` method returns a 3-dimensional numeric array&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# so need to modify the code used for the bipartite nulls&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# use `apply` rather than `sapply` with MARGIN = 3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Inulls.vegan&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;apply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nulls.vegan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MARGIN&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                      &lt;span class=&#34;n&#34;&gt;FUN&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;nestednodf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;statistic[3]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you go for the &amp;ldquo;double bonus&amp;rdquo; round, you should get again a qualitatively different result relative to &lt;code&gt;swap.web&lt;/code&gt;. This is somewhat curious as the two methods are supposed to be very similar&amp;hellip;.&lt;/p&gt;
&lt;!-- =========================================================== --&gt;
&lt;!-- PROPOSING TO NOT INCLUDE THE TWO SECTIONS BELOW---THOUGHTS? --&gt;
&lt;!-- =========================================================== --&gt;
&lt;!-- 1.2.3 BB: using data to understand relationships (simple correlations even) among network metrics  --&gt;
&lt;!-- 1.2.4 BB: sampling effects Potentially using Connor’s Oikos paper / drought impacts—nice in terms of relationships among metrics and also sampling effects (could even play around with? Probably too much time) --&gt;
&lt;!-- Berry section ends here--&gt;
&lt;!-- ======================================= --&gt;
&lt;h2 id=&#34;structure--stability&#34;&gt;Structure &amp;amp; Stability&lt;/h2&gt;
&lt;!-- ======================================= --&gt;
&lt;!-- Fernanda --&gt;
&lt;p&gt;Networks are useful descriptors of community structure but also they matter for the stability of communities. Researcher have investigated the effect of networks structure on community dynamics including their stability since Robert May&amp;rsquo;s pioneer work in 1972 showing mathematically that increased levels of complexity decreases stability of communities. Some concepts of stability you will find in the network literature include:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Local stability&lt;/em&gt;: A system is locally stable if it returns to its original state after being slightly disturbed. Mathematically, local stability is often analyzed through the concept of stability analysis, which involves examining the behavior of a system near an equilibrium point. One common method used to analyze local stability is through linearization, where the system&amp;rsquo;s dynamics are approximated by a linear model around the equilibrium point. This is the concept used by Robert May&amp;rsquo;s work and because its simplicity, has been used by many in the field. However it has important limitations, including the assumption of a local equilibrium, the inability of evaluating any but small perturbations, and the assumption of linear dynamics at equilibrium.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Resilience&lt;/em&gt;: Time to return to a local equilibrium after slightly perturbing the system away from it.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Structural Stability&lt;/em&gt;: In local stability analysis the perturbations act on state variables, limiting the analysis to changes in species abundances only. Conversely, one can study other perturbations using structural stability analysis. A system is considered to be structurally stable if any smooth change in the model itself or in the value of its parameters does not change its dynamic behavior (e.g., existence of equilibrium points, limit cycles, chaos, etc).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Feasibility&lt;/em&gt;: All the constituent species from the community attain positive abundances at equilibrium.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Species persistence&lt;/em&gt;: Typically used in studies of computer simulations, defined as the fraction of initial species that persists until the end of the simulations.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Robustness against species extinctions&lt;/em&gt;: Typically defined in studies of computer simulations as the resistance of a network to loose more species (as secondary extinctions) as result of primary extinctions, which are typically simulated as the removal of species from the network.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We will elaborate more on the effect of network structure on network dynamics and stability in day 3.&lt;/p&gt;
&lt;!-- Fernanda section ends here--&gt;
&lt;!-- ======================================= --&gt;
&lt;!-- ======================================= --&gt;
&lt;!-- Berry --&gt;
&lt;!-- **1.3.1 BB: Topological robustness: compare different network structures** --&gt;
&lt;!-- Berry section ends here--&gt;
&lt;!-- ======================================= --&gt;
&lt;h1 id=&#34;session-info&#34;&gt;Session Info&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;sessionInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## R version 4.4.1 (2024-06-14)
## Platform: aarch64-apple-darwin20
## Running under: macOS Sonoma 14.5
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib 
## LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## time zone: America/Los_Angeles
## tzcode source: internal
## 
## attached base packages:
## [1] grid      stats     graphics  grDevices utils     datasets  methods  
## [8] base     
## 
## other attached packages:
##  [1] gridGraphics_0.5-1   rmarkdown_2.28       viridis_0.6.5       
##  [4] viridisLite_0.4.2    bipartite_2.20       sna_2.7-2           
##  [7] network_1.18.2       statnet.common_4.9.0 vegan_2.6-6.1       
## [10] lattice_0.22-6       permute_0.9-7        webexercises_1.1.0  
## [13] evaluate_0.24.0      kableExtra_1.4.0     knitr_1.48          
## [16] lubridate_1.9.3      forcats_1.0.0        stringr_1.5.1       
## [19] dplyr_1.1.4          purrr_1.0.2          readr_2.1.5         
## [22] tidyr_1.3.1          tibble_3.2.1         ggplot2_3.5.1       
## [25] tidyverse_2.0.0      igraph_2.0.3        
## 
## loaded via a namespace (and not attached):
##  [1] dotCall64_1.1-1   spam_2.10-0       gtable_0.3.5      xfun_0.47        
##  [5] bslib_0.8.0       tzdb_0.4.0        vctrs_0.6.5       tools_4.4.1      
##  [9] generics_0.1.3    parallel_4.4.1    fansi_1.0.6       highr_0.11       
## [13] cluster_2.1.6     pkgconfig_2.0.3   Matrix_1.7-0      lifecycle_1.0.4  
## [17] compiler_4.4.1    fields_16.2       munsell_0.5.1     maps_3.4.2       
## [21] htmltools_0.5.8.1 sass_0.4.9        yaml_2.3.10       pillar_1.9.0     
## [25] jquerylib_0.1.4   MASS_7.3-61       cachem_1.1.0      nlme_3.1-166     
## [29] tidyselect_1.2.1  digest_0.6.37     stringi_1.8.4     bookdown_0.40    
## [33] splines_4.4.1     fastmap_1.2.0     colorspace_2.1-1  cli_3.6.3        
## [37] magrittr_2.0.3    utf8_1.2.4        withr_3.0.1       scales_1.3.0     
## [41] timechange_0.3.0  gridExtra_2.3     blogdown_1.19     hms_1.1.3        
## [45] coda_0.19-4.1     mgcv_1.9-1        rlang_1.1.4       Rcpp_1.0.13      
## [49] glue_1.7.0        xml2_1.3.6        svglite_2.1.3     rstudioapi_0.16.0
## [53] jsonlite_1.8.8    R6_2.5.1          systemfonts_1.1.0
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# replay(pkg.load.msgs)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Interactions</title>
      <link>https://models4data2theory.github.io/courses/wkshp_interactions/</link>
      <pubDate>Thu, 22 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://models4data2theory.github.io/courses/wkshp_interactions/</guid>
      <description>&lt;p&gt;&lt;em&gt;Fitting models to data&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;$$
\newcommand{\L}{\mathcal{L}}
$$&lt;/p&gt;
&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;
&lt;p&gt;A powerful approach to theory-data integration is the use of statistical methods that directly combine empirical data with the mechanistic models of theoretical ecology.
This is the world of model-fitting.&lt;/p&gt;
&lt;p&gt;Perhaps we performed a study in which we counted the number of pollinator visits the flowers of a focal plant species received over a range of different plant densities and now wish to characterize the relationship between these variables.
(To keep things simple, we&amp;rsquo;ll assume each plant has only a single flower.)
Or perhaps we performed an experiment in which we varied the number of pollinator visits that the flowers of the plant species received and are now interested in characterizing how this variation in visits influenced ovule fertilization success (i.e. the proportion of ovules in each flower that were successfully fertilized).&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/motivation-1.png&#34; width=&#34;768&#34; /&gt;
&lt;p&gt;In the past, the common way to characterize any such relationship among variables was to use linear or non-linear least-squares regression (including polynomial regression), extending more recently to mixed effects models.
Generalized linear models and generalized additive models have also become popular, largely because they can accommodate non-Gaussian error structures and flexible, non-linear relationships.&lt;/p&gt;
&lt;p&gt;But these types of statistical models are generally not &amp;ldquo;mechanistic&amp;rdquo;;
their functional forms are not derived from &amp;ldquo;first-principles&amp;rdquo; ecological theory.
Instead, these types of models are by and large only &amp;ldquo;descriptive&amp;rdquo; in nature.&lt;/p&gt;
&lt;p&gt;Theoreticians, on the other hand, have derived many non-statistical (deterministic) mathematical equations to encapsulate how different biological processes should/could influence the patterns we see in nature.
Our goal is to develop the skills to (1) fit such &lt;em&gt;mechanistic models&lt;/em&gt; to data in order to obtain &lt;em&gt;best-fitting parameter estimates&lt;/em&gt; while accommodating &lt;em&gt;process-appropriate error structures&lt;/em&gt;, and (2) compare the &lt;em&gt;relative performance&lt;/em&gt; of several such models in order to identify those that &lt;em&gt;perform best&lt;/em&gt; at representing the data.&lt;/p&gt;
&lt;p&gt;We will achieve these things using the principle of &lt;strong&gt;maximum likelihood&lt;/strong&gt; and an &lt;strong&gt;information-theoretic&lt;/strong&gt; model-comparison approach.
Other approaches for model fitting and comparison &amp;mdash; such as Bayesian statistics &amp;mdash; are often used to accommodate complex data structures and for other pragmatic and epistomological reasons, but those are beyond what we will cover.
That said, most of the principles that we will cover are directly relevant to these other approaches as well.&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;To understand the principle of maximum likelihood, we first need to understand some fundamentals regarding &lt;a href=&#34;#prob_dist&#34;&gt;probability distributions&lt;/a&gt; and &lt;a href=&#34;#lik_fun&#34;&gt;likelihood functions&lt;/a&gt;.
We&amp;rsquo;ll then see how theory models can be incorporated into likelihood functions to convert them from deterministic models to statistical models.
It&amp;rsquo;s this conversion that permits us to fit them to data.
We will then develop our intuition for &lt;a href=&#34;#max_lik&#34;&gt;maximum likelihood parameter estimation&lt;/a&gt; (i.e. model fitting) by first doing it &lt;a href=&#34;#max_lik_math&#34;&gt;analytically&lt;/a&gt; and then learning to use &lt;a href=&#34;#max_lik_optim&#34;&gt;numerical optimization&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Having fit several models to a dataset, we will then dip our toes into the methods of comparing their relative performance using &lt;a href=&#34;#mod_comp&#34;&gt;information criteria&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Skip down to the &lt;a href=&#34;#end_result&#34;&gt;end result&lt;/a&gt; to see where we&amp;rsquo;re headed.&lt;/p&gt;
&lt;h4 id=&#34;required-r-packages&#34;&gt;Required R-packages&lt;/h4&gt;
&lt;p&gt;In principle, everything we&amp;rsquo;ll discuss can be accomplished using functions that come pre-loaded in base R, but we&amp;rsquo;ll make use of the &lt;em&gt;bbmle&lt;/em&gt; package for a few conveniences at the very end.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# install.packages(&amp;#39;bbmle&amp;#39;, dependencies = TRUE) # use to install if needed&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;library&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bbmle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## Loading required package: stats4
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;fundamentals&#34;&gt;Fundamentals&lt;/h2&gt;
&lt;p&gt;We&amp;rsquo;re going to start by assuming our focal response variable doesn&amp;rsquo;t vary in response to any possible covariates at all.
Doing so is useful in helping us think about the different types of probability distributions there are, and which may be best in representing the type of stochastic processes that are likely to have generated our data.&lt;/p&gt;
&lt;h3 id=&#34;prob_dist&#34;&gt;Probability distributions&lt;/h3&gt;
&lt;p&gt;Our two example data sets above share some things in common because they both represent (or are derived from) counts of things.
Counts are integer-valued (i.e. 0, 1, 2, 3, &amp;hellip;) and can&amp;rsquo;t be negative.
The proportion of fertilized ovules is derived from two counts:
the count of fertilized ovules and the total count of available ovules.
Count data are a very common type of data in ecology, so we&amp;rsquo;ll focus on them for our purposes.&lt;/p&gt;
&lt;p&gt;Among the simplest and most appropriate probability distributions to represent such data are the &lt;em&gt;Poisson&lt;/em&gt; and &lt;em&gt;binomial&lt;/em&gt; probability distributions.
Because they represent counts, they are &lt;em&gt;discrete&lt;/em&gt; distributions.&lt;/p&gt;
&lt;h4 id=&#34;the-poisson-distribution&#34;&gt;The Poisson distribution&lt;/h4&gt;
&lt;p&gt;The &lt;em&gt;Poisson distribution&lt;/em&gt; would be appropriate for our dataset in which the count of visitations is our response variable.
It is written as
$$
Pr(k|\lambda) = \frac{\lambda^k e^{-\lambda}}{k!}
$$
and expresses the probability that $k$ events will occur in some interval of time (i.e. that the count of events will be equal to $k$) given that the process responsible for generating the events occurs at a constant mean rate $\lambda$.
You can read $Pr(k|\lambda)$ as the probability of $k$ events &lt;em&gt;given&lt;/em&gt; parameter $\lambda$.
The symbol $e$ represents an exponential (i.e. Euler&amp;rsquo;s number: 2.718&amp;hellip;) and the symbol $!$ represents the factorial function (e.g., $4! = 4 \times 3 \times 2 \times 1$).&lt;/p&gt;
&lt;p&gt;Below, with data on replicate counts of $k$, we will presume that the Poisson applies and then estimate the value of &lt;em&gt;parameter&lt;/em&gt; $\lambda$ that is most likely to have generated those counts.
Intuitively, a higher underlying value of parameter $\lambda$ will result in higher $k$ counts when we draw from this distribution repeatedly
(i.e. when we obtain samples from the data-generating process).
In fact, $\lambda$ reflects the count that we &lt;em&gt;expect&lt;/em&gt; to observe on average across many such draws (a fact that we will prove later).&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/prob_Poiss-1.png&#34; width=&#34;576&#34; /&gt;
&lt;h4 id=&#34;the-binomial-distribution&#34;&gt;The Binomial distribution&lt;/h4&gt;
&lt;p&gt;The &lt;em&gt;binomial distribution&lt;/em&gt; would be appropriate for our dataset in which the proportion of fertilized ovules is our response variable.
More specifically, it will be appropriate after we re-express the number of counts (number of fertilized ovules) expected under the binomial distribution as a proportion of the maximum number of counts possible (the total number of ovules in a flower).
The binomial is written as
$$
Pr(k, n|p) = {n \choose k} p^k (1-p)^{n-k} = \frac{n!}{k!(n-k)!} p^k (1-p)^{n-k}
$$
and expresses the probability of observing $k$ events in a total of $n$ tries given that each event either does or does not happen with constant probabilities $p$ and $1-p$ respectively.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;
The first part of the equation, ${n \choose k}$, is read as &amp;ldquo;$n$ choose $k$&amp;rdquo;.
For example, given $n$ available ovules in a flower, $k$ of them are successfully pollinated.
(The proportion $k/n$ thus corresponds to our measure of fertilization success.) The larger the probability $p$ of success and the larger the number of $n$ tries, the larger that the average count of $k$ successes will be over replicate samples from the data-generating process.&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/prob_Binom-1.png&#34; width=&#34;576&#34; /&gt;
&lt;p&gt;Note that in contrast to the Poisson distribution where the potential count $k$ could be arbitrarily high, $k$ is bounded by the maximum possible value of $n$ under the binomial distribution.
Although the average process rate is assumed constant under both distributions, a flower can be visited many times ($k \geq 0$), making the Poisson more appropriate.
On the other hand, an ovule that has already been fertilized can&amp;rsquo;t be fertilized again (thus $0 \leq k \leq n$), making the binomial more appropriate for our second experiment.&lt;/p&gt;
&lt;h4 id=&#34;other-probability-distributions&#34;&gt;Other probability distributions&lt;/h4&gt;
&lt;p&gt;There are &lt;a href=&#34;https://distribution-explorer.github.io/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;dozens of probability distributions available&lt;/a&gt;, but the Poisson and binomial are arguably the simplest and most useful (and thus among the most commonly assumed in ecology).
One reason for this is that they have only a single free parameter ($\lambda$ and $p$, respectively) given that $n$ is usually known.
These parameters determines not only the expected (mean) value of the distribution of the $k$ counts but also their variance.
(For the Poisson, both the mean and the variance equal $\lambda$,
while for the binomial the mean is $np$ and the variance is $np(1-p)$.)&lt;/p&gt;
&lt;p&gt;Other distributions allow the mean and the variance to be separated.
For example, the &lt;em&gt;negative binomial&lt;/em&gt; and &lt;em&gt;beta-binomial&lt;/em&gt; are discrete examples that generalize the Poisson and binomial distributions to accommodate the common occurrence of over-dispersion (e.g., a variance that is larger than the mean).&lt;/p&gt;
&lt;p&gt;Another distribution that you&amp;rsquo;re probably much more familiar with is the &lt;em&gt;Normal&lt;/em&gt; (a.k.a. &lt;em&gt;Gaussian&lt;/em&gt;) distribution.
The Normal distribution has two parameters $\mu$ and $\sigma$ that respectively determine its mean and variance.
The Normal distribution has a long history of use in ecology and statistics, and is a biologically-appropriate distribution in many circumstances (thanks to the power of the Central Limit Theorem).
It could even be appropriate in the circumstances of our two example data sets because both the Poisson distribution and the binomial distribution converge on the Normal distribution (see the figures above).
But that is only true for sufficiently large $\lambda$, and sufficiently large $n$ and intermediate $p$, respectively.&lt;/p&gt;
&lt;p&gt;In our context of &amp;ldquo;mechanistic&amp;rdquo; models, we often have data from situations where the conditions that lead to a Normal distribution are far from satisfied.
For example, when flower abundances are very low, visitation rates ($\lambda$) will be very low. For small $\mu$ and large $\sigma$, the Normal distribution will also give negative values, which often don&amp;rsquo;t make sense for ecological data sets (you can&amp;rsquo;t have negative counts).
Finally, in the context of fitting mechanistic models, we often don&amp;rsquo;t care about estimating the variance; our goal is typically to estimate the parameter values that maximize a model&amp;rsquo;s fit to the mean of our data.
In that sense, having an extra variance parameter, such as $\sigma$ of the Normal distribution, is actually a nuisance (they&amp;rsquo;re often called &amp;ldquo;nuisance parameters&amp;rdquo;) because it means the model is more complex and thus potentially more challenging to fit.
Just as (or even more) importantly, these nuisance parameters can lead to biased estimates of the other &amp;ldquo;mechanistic&amp;rdquo; parameters that we actually do care about, especially when sample sizes are not large (as is often the case in Ecology).&lt;/p&gt;
&lt;h3 id=&#34;lik_fun&#34;&gt;Likelihood functions&lt;/h3&gt;
&lt;p&gt;Probability distributions express the probability of an outcome given their parameter(s).
For the Poisson distribution we therefore wrote $Pr(k, n | \lambda)$, but more generically for any discrete distribution we&amp;rsquo;ll write $Pr(y | \theta)$,
using $y$ to represent outcomes and $\theta$ the parameter(s).
$Pr(y | \theta)$ is referred to as a &lt;em&gt;probability mass function&lt;/em&gt;;
the input is the parameter values in $\theta$ and the output is the probability of any potential outcome $y$.&lt;/p&gt;
&lt;p&gt;In contrast, when we have data and want to estimate the parameters of a presumed model, we want the reverse.
We then talk of wanting to quantify the &lt;em&gt;likelihood&lt;/em&gt; of any potential parameter value given the data.
We therefore write $\L(\theta | y)$.
$\L(\theta | y)$ is referred to as the &lt;em&gt;likelihood function&lt;/em&gt;;
the input is an outcome and the output is the likelihood that a potential parameter value could have generated that outcome.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;If we observe a given outcome then the &lt;em&gt;most likely&lt;/em&gt; parameter value to have generated that outcome is the one that &lt;em&gt;maximizes&lt;/em&gt; the probability of the outcome.&lt;/strong&gt;
We therefore define the likelihood function to be the probability mass function, setting
$$
\L(\theta | y) = Pr(y | \theta).
$$
This may seem silly, but it&amp;rsquo;s a conceptually important step.&lt;/p&gt;
&lt;p&gt;Assuming the Poisson specifically, we therefore have
$$
\L(\lambda | k)  = Pr(k | \lambda) = \frac{\lambda^k e^{-\lambda}}{k!}.
$$&lt;/p&gt;
&lt;p&gt;The method of maximum likelihood is a matter of finding the value of the parameter that will maximize the output of the likelihood function when we input observed outcomes.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#Prob_mass_dens&#34;&gt;Note on discrete vs. continuous probability distributions&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;max_lik&#34;&gt;Maximum likelihood&lt;/h2&gt;
&lt;h3 id=&#34;intuition&#34;&gt;Intuition&lt;/h3&gt;
&lt;p&gt;As just stated,
maximum likelihood estimation is a matter of the finding the value of the parameter(s) that maximize the likelihood of having observed our data.
Let&amp;rsquo;s walk through how we would do that, first assuming we have only a single data point and then assuming we have many.&lt;/p&gt;
&lt;h4 id=&#34;single-observation&#34;&gt;Single observation&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s say that we sat in a meadow,
watched a single flower for some amount of time,
and observed a total of $k=10$ pollinator visits in that time.
Presuming the Poisson to be an appropriate representation of the visitation process,
we can use our data to determine the most likely value for $\lambda$.&lt;/p&gt;
&lt;p&gt;Remember that $\lambda$ reflects the underlying visitation rate (visits per time) of the process and then think about the following plots of&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the probability mass $Pr(k | \lambda )$ as a function of potential $k$ values (with our data $k=10$ highlighted) for various values of $\lambda$,
and&lt;/li&gt;
&lt;li&gt;the likelihood $\L(\lambda | k)$ as a function of $\lambda$ for $k=10$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notice that the illustrated likelihood function on the right has a maximum at a count of exactly $k=10$.&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;
That is, given our observation of $k=10$ visits, the most likely value of the rate parameter $\lambda$ is 10.
(Hopefully that&amp;rsquo;s not all too surprising;
remember that $\lambda$ reflects the expected (mean) value of a Poisson-distributed variable.)&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/lik_Poiss_single-1.png&#34; width=&#34;768&#34; /&gt;
&lt;h4 id=&#34;multiple-observations&#34;&gt;Multiple observations&lt;/h4&gt;
&lt;p&gt;What do we do when we have not just one but multiple observations?
That is, what if we had a field assistant who also watched a single flower
and counted $k=15$ visits in the same amount of time?
We therefore have two observations, $k = {10, 15}$, to consider.&lt;/p&gt;
&lt;p&gt;If the probability of the first observation is $Pr(k=10 | \lambda)$
and the probability of the second observation is $Pr(k=15 | \lambda)$,
then the probability of observing both is their product,
$Pr(k={10, 15} | \lambda) = Pr(10 | \lambda) \cdot Pr(15 | \lambda)$.&lt;/p&gt;
&lt;p&gt;The same is true for likelihoods.
To get the overall (&amp;ldquo;joint&amp;rdquo;) likelihood of $\lambda$ given &lt;em&gt;both&lt;/em&gt; observations,
we simply multiply their likelihoods.
Thus
$\L(\lambda | k={10, 15}) = \L(\lambda | k=10) \cdot  \L( \lambda | k=15)$.
More specifically,
$$
\L(\lambda | k={10, 15})  =
\frac{\lambda^{10} e^{-\lambda}}{10!}
\cdot
\frac{\lambda^{15} e^{-\lambda}}{15!}.
$$
As the next figure shows,
$\L{\lambda | k={10, 15})$ has a maximum at $\lambda = 12.5$
(which corresponds to the average of the two observations).&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/lik_Poiss_two-1.png&#34; width=&#34;384&#34; /&gt;
&lt;p&gt;For an arbitrary number of $n$ observations (i.e. $k={ k_1, k_2, \ldots, k_n}$),
we have a product of $n$ observation-specific likelihoods.
Our joint likelihood function with which to determine $\lambda$ thus becomes a function of these observation-specific likelihoods,
$$
\L(\lambda |k)
= \prod_{i=1}^n \frac{\lambda^{k_i} e^{-\lambda}}{k_i!}
$$
where the symbol $\prod_{i=1}^n$ denotes the product of elements $i=1$ to $n$.
That is,
$$
\prod_{i=1}^n \frac{\lambda^{k_i} e^{-\lambda}}{k_i!}
= \frac{\lambda^{k_1} e^{-\lambda}}{k_1!}
\cdot
\frac{\lambda^{k_2} e^{-\lambda}}{k_2!}
\cdot
\ldots
\cdot
\frac{\lambda^{k_n} e^{-\lambda}}{k_n!}.
$$&lt;/p&gt;
&lt;h3 id=&#34;why-the-negative-log-likelihood&#34;&gt;Why the negative log-likelihood?&lt;/h3&gt;
&lt;p&gt;We want the value of $\lambda$ that maximizes the joint likelihood over all our observations.
But we&amp;rsquo;ve created a numerical problem in the previous step.
Probabilities are numbers bounded by 0 and 1,
and therefore so are likelihoods.
As a result, by multiplying all those likelihoods together, our joint likelihood will become a smaller and smaller number with every data point we add to our dataset!
In fact, as our number of observations grows their joint likelihood becomes a vanishingly small number that neither our heads nor computers can deal with!&lt;/p&gt;
&lt;p&gt;The solution is the logarithm.&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;
Processes that are multiplicative on the natural scale become additive on the logarithmic scale, i.e.
$$
\ln ( x\cdot y \cdot z) = \ln(x) + \ln(y) + \ln(z).
$$
Therefore,
$$
\ln \L(\lambda |k)
= \ln \left (\prod_{i=1}^n \frac{\lambda^{k_i} e^{-\lambda}}{k_i!} \right)
= \sum_i^n \ln \left (\frac{\lambda^{k_i} e^{-\lambda}}{k_i!} \right)
$$
where
$$
\sum_i^n \ln \left (\frac{\lambda^{k_i} e^{-\lambda}}{k_i!} \right)
= \ln \left(\frac{\lambda^{k_1} e^{-\lambda}}{k_1!} \right )
+
\ln \left( \frac{\lambda^{k_2} e^{-\lambda}}{k_2!} \right)
+
\ldots
+
\ln \left (\frac{\lambda^{k_n} e^{-\lambda}}{k_n!} \right ).
$$
Thus the &lt;em&gt;log-likelihood&lt;/em&gt; increases (rather than decreases) in value as the number of observations increases.
Big numbers are no problem to deal with, so we&amp;rsquo;ve successfully avoided our numerical problem.&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/neglog-1.png&#34; width=&#34;384&#34; /&gt;
&lt;p&gt;But taking the logarithm has a side effect because the logarithm of a number between 0 and 1 returns a &lt;em&gt;negative&lt;/em&gt; number.
Since each of the individual likelihoods is between 0 and 1,
a side-effect of taking $\ln \L$ is that we&amp;rsquo;re now adding up lots of negative numbers.
That&amp;rsquo;s not a problem because we can just take the negative log-likelihood to get back to a positive number.
But importantly, as a consequence,
&lt;strong&gt;in order to &lt;em&gt;maximize&lt;/em&gt; the likelihood $\L$, we need to &lt;em&gt;minimize&lt;/em&gt; the negative log-likelihood $-\ln \L$&lt;/strong&gt;
to find the parameter value that best fits the data.&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/nlnlik_Poiss-1.png&#34; width=&#34;384&#34; /&gt;
&lt;h3 id=&#34;finding-the-mles&#34;&gt;Finding the MLEs&lt;/h3&gt;
&lt;p&gt;For some models it is possible to determine the values of the parameters that maximize the likelihood function analytically.
That is, it&amp;rsquo;s possible to solve for the maximum likelihood parameters
(i.e. the maximum likelihood estimators (&amp;ldquo;MLEs&amp;rdquo;)).
Doing so for $\lambda$ of the Poisson, we can
(i) build intuition to better understand what numerical methods (&amp;ldquo;optimizers&amp;rdquo;) are about, and
(ii) prove that the MLE for $\lambda$ of the Poisson is the mean of the $k$ observations (as I simply proclaimed above).
However, I&amp;rsquo;ll relegate the latter of these to the &lt;a href=&#34;of_potential_utility_or_interest&#34;&gt;Of Potential Utility or Interest&lt;/a&gt; page.&lt;/p&gt;
&lt;h4 id=&#34;max_lik_math&#34;&gt;Analytical intuition&lt;/h4&gt;
&lt;p&gt;We&amp;rsquo;ll do this rather abstractly&amp;hellip;&lt;/p&gt;
&lt;p&gt;Suppose we have some arbitrary function, like this polynomial describing a parabola
$f(x) = a + b (x-c)^2$ depicted in the following figure.
The way to find the value of $x$ where $f(x)$ is at its minimum value is to find the value of $x$ where the slope of $f(x)$ (with respect to $x$) is zero.&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/fig_poly-1.png&#34; width=&#34;384&#34; /&gt;
&lt;p&gt;How do we determine the slope of $f(x)$ as a function of $x$?
We take the derivative of $f(x)$ with respect to $x$: $\frac{d ; f(x)}{dx}$.
For our polynomial, $\frac{d ; f(x)}{dx} = 2b(x-c)$,
which even R has the ability to solve symbolically:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;^2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## b * (2 * (x - c))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Setting $\frac{d; f(x)}{dx} = 2b(x-c) = 0$
(since that&amp;rsquo;s where $f(x)$ will have its minima (or maxima)&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;),
we use a little algebra to solve for $x$:
$$
2b(x-c)=0 \implies 2bx-2bc=0 \implies 2bx = 2bc \implies x=c
$$
(which correctly equals the location of the minimum at $x=2$,
as shown in the above figure).
We can do the same thing for likelihood functions to obtain their MLEs.
Doing so often leads to useful insight into the processes and variables that cause parameter estimates to change in value.&lt;/p&gt;
&lt;h4 id=&#34;max_lik_optim&#34;&gt;Numerical optimization&lt;/h4&gt;
&lt;p&gt;There are two basic parts to finding the MLE by numerical means:
coding the negative log-likelihood function and choosing the optimization method to find its minimum.&lt;/p&gt;
&lt;h5 id=&#34;coding-the-likelihood&#34;&gt;Coding the likelihood&lt;/h5&gt;
&lt;p&gt;For the Poisson, we have the negative log-likelihood function&lt;/p&gt;
&lt;p&gt;$$
-\ln \L(\lambda | k) =
\sum_i^n \ln \left (\frac{\lambda^{k_i} e^{-\lambda}}{k_i!} \right).
$$
You could certainly write code to define an R function to implement this calculation
(see the &lt;a href=&#34;of_potential_utility_or_interest&#34;&gt;Of Potential Utility or Interest&lt;/a&gt; page),
and sometimes it&amp;rsquo;s necessary to do that for more complex likelihoods.
But R has built-in functions for most probability distributions that are robust, fast, and easy to use.
These R functions are the &amp;ldquo;density functions&amp;rdquo; of the probability distributions.&lt;/p&gt;
&lt;p&gt;For example, while R&amp;rsquo;s function &lt;code&gt;runif(n, min, max)&lt;/code&gt; draws &lt;code&gt;n&lt;/code&gt; random values from the uniform probability distribution bounded by &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; parameter values,
the corresponding density function &lt;code&gt;dunif(x, min, max)&lt;/code&gt; returns the likelihood of the value &lt;code&gt;x&lt;/code&gt; given &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.
For the Poisson, we have &lt;code&gt;dpois(x, lambda)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that, by default, the likelihood is returned on the natural scale.
To obtain the &lt;em&gt;negative log&lt;/em&gt;-likelihood of &lt;code&gt;x&lt;/code&gt;, we use &lt;code&gt;-dpois(x, lambda, log = TRUE)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When &lt;code&gt;x&lt;/code&gt; represents a vector of values (multiple observations), we obtain a vector of corresponding negative log-likelihoods (one for each observation).
Since we want the overall joint negative log-likelihood of all the observations,
we have to sum their negative log-likelihoods together: &lt;code&gt;-sum(dpois(x, lambda, log = TRUE))&lt;/code&gt;.
We can define our own R function to implement this and use it more conveniently.
Notice that we define the function with only &lt;code&gt;lambda&lt;/code&gt; as an argument.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Define the negative log-likelihood&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;nlL.pois&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dpois&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;log&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;TRUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Continuing with our dataset of $k = {10, 15}$ observations from above,
we can apply our function as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Define k globally for our nlL.pois() function to use.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Demonstrate use of nlL.pois() for two hypothetical values of lambda.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;nlL.pois&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## [1] 5.056302
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;nlL.pois&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;12.4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## [1] 4.861272
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;optimization&#34;&gt;Optimization&lt;/h5&gt;
&lt;p&gt;Given data $k={10, 15}$, we now need to find the value of $\lambda$ that minimizes our negative log-likelihood function &lt;code&gt;nlL.pois()&lt;/code&gt;.
For many circumstances, the R function &lt;code&gt;optim()&lt;/code&gt; is the go-to function for doing so because it is robust and has several standard optimization methods and control options to choose from.
It comes in base R, so there&amp;rsquo;s no package to load.&lt;/p&gt;
&lt;p&gt;At minimum, we have to pass &lt;code&gt;optim(par, fn, ...)&lt;/code&gt; where &lt;code&gt;fn&lt;/code&gt; is the function we wish to minimize and &lt;code&gt;par&lt;/code&gt; is a guess at an initial parameter value at which the optimizer will start its search.
(You can ignore the warning message in the following example.&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;init.par&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;optim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init.par&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nlL.pois&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## Warning in optim(init.par, nlL.pois): one-dimensional optimization by Nelder-Mead is unreliable:
## use &amp;#34;Brent&amp;#34; or optimize() directly
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## $par
## lambda 
##   12.5 
## 
## $value
## [1] 4.860468
## 
## $counts
## function gradient 
##       34       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The output of &lt;code&gt;optim()&lt;/code&gt; includes the MLE for our parameter $\lambda$,
the &lt;code&gt;value&lt;/code&gt; of our negative log-likelihood function at the MLE,
and a &lt;code&gt;convergence&lt;/code&gt; error code (with 0 indicating success).&lt;/p&gt;
&lt;h3 id=&#34;max_lik_class&#34;&gt;Let&amp;rsquo;s try it&lt;/h3&gt;
&lt;h5 id=&#34;repeat-for-yourself&#34;&gt;Repeat for yourself&lt;/h5&gt;
&lt;p&gt;In-class 
  &lt;i class=&#34;fas fa-clock  pr-1 fa-fw&#34;&gt;&lt;/i&gt; 10-15 minutes&lt;/p&gt;
&lt;p&gt;Download &lt;a href=&#34;https://models4data2theory.github.io/courses_Rscripts/ModelFitting_1.R&#34;&gt;ModelFitting_1.R&lt;/a&gt; to implement what we just did with the $k={10, 15}$ data set and Poisson distribution.
Then try generating different data sets that vary in their sample size to see how close you get to the true value of $\lambda$ with which you generated the data.
(We&amp;rsquo;ll address estimation uncertainty through the use of confidence intervals later.)&lt;/p&gt;
&lt;h5 id=&#34;real-binomial-data&#34;&gt;Real binomial data&lt;/h5&gt;
&lt;p&gt;Your actual challenge, however, is to generate your own data and write your own code to analyse it.&lt;/p&gt;
&lt;p&gt;The data set will be contributed to by everyone in the class.
Each of you will take one (or more) &lt;em&gt;Delphinium&lt;/em&gt; seed pods and count both the total number of ovules and the number that were successfully fertilized.
Enter your data on &lt;a href=&#34;https://docs.google.com/spreadsheets/d/e/2PACX-1vTyyqthYKtedUdgRCOE37ec-oA4TzY6Mq8glR9bWr8ORhGQjWZlkeIuM5AgdGa8-zHE9pJma8C3n4_n/pub?gid=0&amp;amp;single=true&amp;amp;output=csv&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this GoogleSheet&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As soon as you&amp;rsquo;re done with data entry, download the data as a &lt;em&gt;csv&lt;/em&gt; file and start analyzing it.
(You can re-download it again after everyone&amp;rsquo;s finished entering their data.
You only need one data point to start fitting this one-parameter model!)&lt;/p&gt;
&lt;p&gt;Rather than using a Poisson, you&amp;rsquo;ll want to assume a binomial process.
Your goal is to estimate $p$, the average probability of fertilization success.
Download &lt;a href=&#34;https://models4data2theory.github.io/courses_Rscripts/ModelFitting_2.R&#34;&gt;ModelFitting_2.R&lt;/a&gt; to help you get going.&lt;/p&gt;
&lt;h2 id=&#34;model-fitting&#34;&gt;Model fitting&lt;/h2&gt;
&lt;p&gt;Up to this point, we have assumed that the process that is reflected in our data,
be it the flower visitation rate $\lambda$ or the fertilization success probability $p$,
is well-represented as being a constant value that is independent of any other contributing factor.
Visually, if we actually had data like that introduced at the very start of today, our models so far would correspond to the horizontal lines in the following figures.
That is, we&amp;rsquo;d be assuming that visitation counts are independent of plant density,
and that the proportions of ovules fertilized are independent of visitation count.
All variation is noise.&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/motivation_constant-1.png&#34; width=&#34;768&#34; /&gt;
&lt;p&gt;We can think of these models of constant $\lambda$ and $p$ as being our simplest 1-parameter &amp;ldquo;null&amp;rdquo; models;
if you didn&amp;rsquo;t have any other information, your best prediction for the expected value of a future data point would be the mean of current data.
Clearly, these data visualizations indicate that these null models do not capture all the information that a more complex model could potentially capture.
Although there is plenty of noise, the visitation rate and the fertilization success probability appear to be increasing functions of plant density and visitation count, respectively.
That is, $\lambda$ would probably be better considered to be a function of plant density and $p$ would probably be better considered to be a function of visitation count.
So how do we go about encoding that in our models?&lt;/p&gt;
&lt;p&gt;Well, there are many ways that we could do it.
We could go the route of using &lt;em&gt;GLMs&lt;/em&gt; and &lt;em&gt;GAMs&lt;/em&gt; that permit us to continue to appropriately represent non-Gaussian error structures and potentially non-linear relationships
(see the &lt;a href=&#34;of_potential_utility_or_interest&#34;&gt;Of Potential Utility or Interest&lt;/a&gt;).
But, as motivated above, our goal is to fit mechanistic models instead.&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3 id=&#34;mechanistic-models&#34;&gt;Mechanistic models&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s consider our visitation count vs. plant density dataset.
Even if the total number of pollinators that are flying in the sky is invariant (constant) with respect to the density of our focal plant species, it seems somewhat intuitive that we should see more total visits to the focal plant in areas where the focal plant&amp;rsquo;s density is higher.
That is, setting aside targeted searching and all other kinds of potential pollinator behavior, it should be true that the more plants there are, the greater the chance that a pollinator will bump into any one of them by random chance alone.
The mathematically simplest model, we&amp;rsquo;ll call it $f_1$, to describe such a presumed dependence of $\lambda$ on $P$ would be
$$
\text{Visitation rate }\lambda = f_1(P) = a P,
$$
where a new parameter $a$ encapsulating what may potentially be several aspects of the pollinator&amp;rsquo;s search effort, including its flying speed, its preference for the focal plant, etc..
The higher the value of $a$, the steeper the slope of the assumed biological relationship between $\lambda$ and $P$ and hence the steeper the slope of observed visitation counts versus plant density we expect to see in our data.
In the literature on Consumer-Resource theory, this model is referred to as the &lt;em&gt;Holling Type I functional response&lt;/em&gt;.&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/motivation_prop-1.png&#34; width=&#34;336&#34; /&gt;
&lt;p&gt;A more flexible (and possibly more realistic) second model describes $\lambda$ as increasing with $P$ in a monotonically-saturating fashion to encode the hypothesis that visitation rates can&amp;rsquo;t increase with $P$ forever.
That is, while visitation rates are likely determined by search effort and plant density at low $P$ (just like for model $f_1$), they are probably bounded at some maximum possible visitation rate at high values of $P$.
If, for example, a pollinator spends $h$ minutes per visit to each encountered flower, then the maximum possible visitation rate at high values of $P$ (where there is effectively no time needed to search and find the next flower) is $1/h$ visits per minute.
The two-parameter model
$$
\text{Visitation rate }\lambda = f_2(P) = \frac{a P}{1 + a h P}
$$
encapsulates this.
The more plants there are, the more that each pollinator spends time &amp;ldquo;handling&amp;rdquo; rather than searching and encountering more plants.
In the literature, this model is referred to as the &lt;em&gt;Holling Type II functional response&lt;/em&gt;.
(An alternative but deterministically-equivalent parameterization is referred to as the &lt;em&gt;Michaelis-Menten&lt;/em&gt; model.)
Note that when $h=0$, model $f_2$ collapses back to model $f_1$.
Model $f_1$ is therefore nested within $f_2$.&lt;/p&gt;
&lt;p&gt;Lastly, an even more flexible (and possibly even more realistic) third model describes $\lambda$ as increasing with $P$ in a sigmoidal fashion to encode the hypothesis that a pollinator&amp;rsquo;s search rate may additionally be limited at low $P$.
For example, the rate at which a pollinator searches for plants may itself increase with plant density; they may develop an ever better &amp;ldquo;search image&amp;rdquo; as they encounter more plants.
The three-parameter model
$$
\text{Visitation rate }\lambda = f_3(P) = \frac{a P^\theta}{1 + a h P^{\theta}}
$$
encapsulates this when the new parameter $\theta$ (theta) takes on values greater than 1.
This model is most appropriately referred to as the &lt;em&gt;Holling-Real Type III functional response&lt;/em&gt;.&lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;
Note that when $\theta=1$, model $f_3$ collapses back to model $f_2$ since $x^1 = x$.&lt;/p&gt;
&lt;h3 id=&#34;modifying-the-likelihood&#34;&gt;Modifying the likelihood&lt;/h3&gt;
&lt;p&gt;To fit the three $f_1-f_3$ models to our data we need to incorporate them into our likelihood function.
To do so we insert each of them in for $\lambda$.
Many refer to the resulting statistical model (i.e. the likelihood function) as being composed of a &lt;em&gt;deterministic skeleton&lt;/em&gt; and a &lt;em&gt;stochastic shell&lt;/em&gt;.
For example, for model $f_1$ we have
$$
-\ln \L_1(a | k, P)
= \sum_i^n \ln \left (\frac{f_1^{k_i} e^{-f_1}}{k_i!} \right)
= \sum_i^n \ln \left (\frac{(a P)^{k_i} e^{-a P}}{k_i!} \right).
$$
Notably, unlike our original negative log-likelihood function to which we supplied only the response variable data (visitation counts $k = {k_1, k_2, \ldots, k_n }$) in order to estimate the constant $\lambda$, we must now supply the both response variable data and the covariate data (of corresponding plant densities $P = {P_1, P_2, \ldots, P_n }$) in order to estimate up to three constants ($a$, $h$, and $\theta$) for the three models.&lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;
But because $P$ is the same for all models, we can just leave it defined in R&amp;rsquo;s global environment (rather than defining it within the function&amp;rsquo;s internal environment).&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;ll need a little more dummy data, so let&amp;rsquo;s create it using &lt;code&gt;runif()&lt;/code&gt; and &lt;code&gt;rpois()&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;set.seed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0.33&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# True value of &amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Sample size&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;P&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;runif&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Plant densities&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Visitation counts&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;k[i]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rpois&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;P[i]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Generate a k for each P assuming Type 1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;data.frame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;P&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;round&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;##       P  k
## 1  26.6  6
## 2  37.2  9
## 3  57.3 22
## 4  90.8 33
## 5  20.2  6
## 6  89.8 33
## 7  94.5 26
## 8  66.1 18
## 9  62.9 19
## 10  6.2  1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we define the negative log-likelihood for the $f_1$ and use &lt;code&gt;optim()&lt;/code&gt; to estimate the MLE for its $a$ parameter.
(Again we&amp;rsquo;ll ignore the warning for this 1-dimensional model.)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;nlL.pois.f1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;par&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;par[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dpois&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;log&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;TRUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Estimate &amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;fit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;optim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;par&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nlL.pois.f1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## Warning in optim(par = list(a = 0.2), fn = nlL.pois.f1): one-dimensional optimization by Nelder-Mead is unreliable:
## use &amp;#34;Brent&amp;#34; or optimize() directly
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## $par
##         a 
## 0.3136914 
## 
## $value
## [1] 24.37161
## 
## $counts
## function gradient 
##       28       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# True &amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## [1] 0.33
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Estimated &amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;fit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;par&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;##         a 
## 0.3136914
&lt;/code&gt;&lt;/pre&gt;&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/motivation_type1-1.png&#34; width=&#34;336&#34; /&gt;
&lt;h3 id=&#34;lets-try-it&#34;&gt;Let&amp;rsquo;s try it&lt;/h3&gt;
&lt;h5 id=&#34;repeat-for-yourself-1&#34;&gt;Repeat for yourself&lt;/h5&gt;
&lt;p&gt;In-class 
  &lt;i class=&#34;fas fa-clock  pr-1 fa-fw&#34;&gt;&lt;/i&gt; 30-45 minutes&lt;/p&gt;
&lt;p&gt;Download &lt;a href=&#34;https://models4data2theory.github.io/courses_Rscripts/ModelFitting_3.R&#34;&gt;ModelFitting_3.R&lt;/a&gt;.
The first part generates a random dataset.
It then repeats the fitting of the $f_1$ model that we just did.&lt;/p&gt;
&lt;p&gt;Your challenge is expand on the script to fit the $f_2$ and $f_3$ models to the same dataset.
Summarize what you learn by comparing the three models&#39;
(1) parameter MLEs to each other and the values with which the dataset was generated, and
(2) their minimized negative log-likelihoods (i.e. the value of their negative log-likelihood at their parameter MLEs).
Which model&amp;rsquo;s parameters got closest to the truth?
Which model is the &lt;em&gt;best-fitting&lt;/em&gt;?
(Is it a higher or a lower negative log-likelihood that is better?)
Which model is the &lt;em&gt;best-performing&lt;/em&gt;?&lt;/p&gt;
&lt;p&gt;But before you get going, take note of two things about&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Coding the likelihood, and&lt;/li&gt;
&lt;li&gt;Initial values &amp;amp; NaNs.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;coding-the-likelihood-1&#34;&gt;Coding the likelihood&lt;/h4&gt;
&lt;p&gt;The function we used to define the negative log-likelihood for the $f_1$ model above had only a single &lt;code&gt;par&lt;/code&gt; argument from which we &amp;ldquo;extract&amp;rdquo; parameter &lt;code&gt;a&lt;/code&gt; using &lt;code&gt;a &amp;lt;- par[&#39;a&#39;]&lt;/code&gt;.
(That is, we&amp;rsquo;ve added a line of code relative to what we did when we were just focused on $\lambda$.)
You&amp;rsquo;ll want to do the same thing when defining the likelihood functions for models $f_2$ and $f_3$; your likelihood functions must have only one &lt;code&gt;par&lt;/code&gt; argument from which each parameter is extracted.&lt;/p&gt;
&lt;h4 id=&#34;initial-values--nans&#34;&gt;Initial values &amp;amp; NaNs&lt;/h4&gt;
&lt;p&gt;In general, the more data you have and the simpler the model, the less sensitive the optimization will be to your initial parameter value guess.
In our simple example case involving $f_1$ and a linear relationship, almost any reasonable initial value for $a$ would have worked.&lt;/p&gt;
&lt;p&gt;In slightly more complex cases, you can often get a good enough guess by eyeballing your data and thinking about how the parameters of your deterministic function should influence its shape.
For example, for the $f_2$ model, parameter $a$ controls the slope at the origin at $P=0$ while parameter $h$ controls the level of the asymptotic maximum value of $1/h$ as $P\rightarrow \infty$, both of which can be read of a plot of the data.
Otherwise, the best way to proceed is to fit a simpler model and to use its MLEs to inform your guess for the next more complex model.
(That is, fit $f_1$ first and use its estimate for $a$ to inform the initial value for $a$ in model $f_2$, etc.)&lt;/p&gt;
&lt;p&gt;In complex cases, it&amp;rsquo;s often wise to try out several different starting values to ensure that you always arrive at the same MLE values.
Otherwise you run the risk of your optimizer finding a &lt;em&gt;local&lt;/em&gt; (rather than &lt;em&gt;global&lt;/em&gt;) minimum in the likelihood surface (see below).&lt;/p&gt;
&lt;p&gt;You may get a negative log-likelihood output of &lt;code&gt;NaN&lt;/code&gt; if your initial guess (or a value attempted during the optimization) is incompatible with the data.
&lt;code&gt;optim()&lt;/code&gt; will tell you when that happens.
If that happens for the initial value, try again with a different value.
If it happens during the optimization, it&amp;rsquo;s typically not a problem if a convergence code of 0 is obtained.&lt;/p&gt;
&lt;h2 id=&#34;mod_comp&#34;&gt;Model comparison&lt;/h2&gt;
&lt;p&gt;In general, the more parameters a model has (i.e. the more &lt;em&gt;parametrically complex&lt;/em&gt; it is), the better it will fit the data.
Indeed, a little simplistically speaking, if you have a model that has as many free parameters as you have data points, then your model can fit the data perfectly with no unexplained residual variation leftover!&lt;sup id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;
A model&amp;rsquo;s &lt;em&gt;fit&lt;/em&gt; to the data as reflected by its likelihood (or its $R^2$ value) is thus rarely useful on its own when we want to compete different models against each other to ask which is &amp;ldquo;the best&amp;rdquo;.
Rather, the principle of parsimony (Occam&amp;rsquo;s razor) motivates us to identify the best-&lt;em&gt;performing&lt;/em&gt; model.
Typically the best-performing model is the one that &lt;em&gt;maximizes fit while minimizing complexity&lt;/em&gt; relative to the other considered models.
If two models fit the data equally well but one uses fewer parameters to achieve that fit, then it is the better-performing model.
Currently, the most widely used tools for quantifying relative model performance are based on &lt;em&gt;information theory&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&#34;inf_crit&#34;&gt;AIC &amp;amp; BIC&lt;/h3&gt;
&lt;p&gt;Two information-theoretic indices of model performance are by far the most popularly used in ecology:
the Akaike Information Criterion (&lt;em&gt;AIC&lt;/em&gt;)
and the Bayesian Information Criterion (&lt;em&gt;BIC&lt;/em&gt;, a.k.a. the Schwartz Information Criterion).
The practical difference between these three criteria is in how they quantify model complexity.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;AIC&lt;/em&gt; score of a model is calculated as twice the minimized negative log-likelihood plus twice the number of parameters $p$:
$$
AIC = - 2 \ln \hat{\L} + 2 p.
$$
Note two things:&lt;sup id=&#34;fnref:11&#34;&gt;&lt;a href=&#34;#fn:11&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;11&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We&amp;rsquo;re using the modified symbol $\hat{\L}$ rather than just $\L$ to indicate that we are using the &lt;em&gt;minimized&lt;/em&gt; value of negative log-likelihood (i.e. its value at the model&amp;rsquo;s parameter MLEs).&lt;/li&gt;
&lt;li&gt;Because a lower $-\ln \hat{\L}$ value reflects a better fit to the data, adding a model&amp;rsquo;s parameter count with $+2p$ reflects a &lt;em&gt;complexity penalty&lt;/em&gt; that makes a model&amp;rsquo;s &lt;em&gt;AIC&lt;/em&gt; value larger.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Similarly, the $BIC$ score of a model is calculated as&lt;/p&gt;
&lt;!-- $$ --&gt;
&lt;!-- AICc =  - 2 \ln \hat{\L} + 2 p + \frac{2 p (p + 1)}{n-p-1} --&gt;
&lt;!-- $$ --&gt;
&lt;!-- and --&gt;
&lt;p&gt;$$
BIC = - 2 \ln \hat{\L} +  \ln(n) p,
$$
where the logarithm of the dataset&amp;rsquo;s sample size $n$ also contributes to the complexity penalty term.
Therefore, larger datasets impose a greater penalty on more parametrically-complex models for &lt;em&gt;BIC&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For both criteria, the model with the &lt;em&gt;lowest&lt;/em&gt; score is considered the best-performing model.
Note that when comparing models the dataset cannot change.
All models have to be fit to the same dataset.
More specifically, although the covariates can be different for different models, the response variable data (e.g., our visitation counts) must remain the same.&lt;/p&gt;
&lt;h4 id=&#34;relative-performance&#34;&gt;Relative performance&lt;/h4&gt;
&lt;p&gt;Having identified the best-performing model, it is natural to ask just how much better the best-performing model is relative to the others.
We can do that by calculating their $\Delta$ differences.
That is, the performance of the $i^{th}$ model relative to the best performing model is calculated as
$$
\Delta_i = AIC_i - AIC_{min}.
$$
The best-performing model will thus have $\Delta_i = 0$ and all others will have $\Delta_i &amp;gt; 0$.
The bigger the difference, the better the best-performing model.
Because we like cut-offs&lt;sup id=&#34;fnref:12&#34;&gt;&lt;a href=&#34;#fn:12&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;12&lt;/a&gt;&lt;/sup&gt;,
by rule-of-thumb convention,
a difference of at least 2 units is deemed to reflect &amp;ldquo;substantial&amp;rdquo; support in favor of the best-performing model,
a 2-4 unit difference is deemed as providing &amp;ldquo;strong&amp;rdquo; support&lt;sup id=&#34;fnref:13&#34;&gt;&lt;a href=&#34;#fn:13&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;13&lt;/a&gt;&lt;/sup&gt;,
a 4-7 unit difference as &amp;ldquo;considerably less&amp;rdquo; support,
while models having $\Delta_i &amp;gt; 10$ are deemed to have essentially no support.&lt;/p&gt;
&lt;h3 id=&#34;lets-try-it-1&#34;&gt;Let&amp;rsquo;s try it&lt;/h3&gt;
&lt;p&gt;In-class 
  &lt;i class=&#34;fas fa-clock  pr-1 fa-fw&#34;&gt;&lt;/i&gt; 10-15 minutes&lt;/p&gt;
&lt;p&gt;Adding to your updated copy of &lt;a href=&#34;https://models4data2theory.github.io/courses_Rscripts/ModelFitting_3.R&#34;&gt;ModelFitting_3.R&lt;/a&gt;, write functions for $AIC$ and $BIC$ and use them to identify the best-performing model among our three $f_1$ - $f_3$ models.
Do your inferences differ from your earlier evaluation of the models?&lt;/p&gt;
&lt;h3 id=&#34;alternatives&#34;&gt;Alternatives&lt;/h3&gt;
&lt;p&gt;Information criteria like &lt;em&gt;AIC&lt;/em&gt; and &lt;em&gt;BIC&lt;/em&gt; are popular because they are super easy to implement.
They also have the benefit of enabling the comparison of any set of models for which a likelihood can be calculated and the parameters can be counted (or estimated).
In particular, the models in the set need not be nested subsets of each other as is necessary for the alternative model-comparison approach of &lt;em&gt;Likelihood Ratio Tests&lt;/em&gt;.  (Our $f_1$ - $f_3$ models &lt;em&gt;are&lt;/em&gt; nested subsets, because $f_3$ can be reduced to $f_2$ which can be reduced to $f_1$, so likelihood ratio tests could be used.)&lt;/p&gt;
&lt;p&gt;There are also several other information criteria available.
The commonly-used &lt;em&gt;AICc&lt;/em&gt; attempts to account for a bias towards more complex models that occurs for &lt;em&gt;AIC&lt;/em&gt; when sample sizes are small.
For models that are linear in their parameters and have residuals that are well-approximated by a Normal distribution,
$$
AIC_c = AIC + \frac{2k(k+1)}{n-k-1}.
$$
Unfortunately there is no similarly simple equation for nonlinear models with non-Normal residuals.&lt;/p&gt;
&lt;p&gt;Other approaches for balancing fit and complexity include the
&lt;em&gt;Fisher Information Approximation&lt;/em&gt; (FIA) which considers not just a model&amp;rsquo;s parametric complexity but also its geometric complexity (i.e. how flexible it is),
and various forms of &lt;em&gt;cross-validation&lt;/em&gt; whereby subsets of a given data set are repeatedly left out of the fitting (&amp;ldquo;training&amp;rdquo;) process to be used as &amp;ldquo;test data&amp;rdquo; with which to evaluate the model&amp;rsquo;s predictive ability.
In the latter, unnecessarily complex models will over-fit the training data and will therefore perform poorly on the test data.&lt;/p&gt;
&lt;h3 id=&#34;philosophies&#34;&gt;Philosophies&lt;/h3&gt;
&lt;p&gt;Much has been written about the pros and cons, foundations and assumptions, epistomological and pragmatic differences between the various approaches to model comparison.
That&amp;rsquo;s particularly true for AIC vs. BIC.
The comparison is often framed as being rather absolute and clear (especially in the ecological literature), but my sense is that it is far more nuanced and muddy.&lt;/p&gt;
&lt;p&gt;Much of the discussion pertains to questions of motivation in comparing alternative models.
Is it to describe your data?  Is it to predict new data?  Is it to explain your data?
If it&amp;rsquo;s to predict, then what kind of prediction are you wanting to make (e.g., within-sample, out-of-sample, out-of-range, forecast, etc.)?
Conceptually, all questions will arrive at the same conclusion regarding which model is &amp;ldquo;best&amp;rdquo; when your data set is very large and sufficiently representative of all possibilities, but that is rarely if ever the case.
Therefore, choices about which approach to take have to be made.
For example, the derivation of AIC is motivated by a desire to maximize out-of-sample predictive ability
(i.e. minimizing the prediction error when predicting what equivalent data sets would look like).
Asymptotically (as sample sizes increase), AIC is equivalent to the leave-one-out form of cross-validation.
In contrast, the derivation of BIC is motivated by a desire to identify the &amp;ldquo;true&amp;rdquo; model
(i.e. to interpret or draw inferences about biology), and in that sense are more similar to leave-many-out forms of cross-validation and asymptotically converge on criteria like FIA.&lt;/p&gt;
&lt;p&gt;That said, most of the mathematical and statistical basis for contrasting the different approaches is limited to linear regression type models.
Thus, while I consider it important to go beyond what most ecologists seem to be doing
(i.e. ignore the differences and just go with AIC because everyone else is using it)
by thinking about your motivations and the trade-offs among them,
I would say that a fair degree of pragmatism remains warranted.&lt;/p&gt;
&lt;h2 id=&#34;uncertainty&#34;&gt;Uncertainty&lt;/h2&gt;
&lt;h3 id=&#34;likelihood-surfaces&#34;&gt;Likelihood surfaces&lt;/h3&gt;
&lt;p&gt;When we have more than one parameter, we talk about the likelihood function as describing a &amp;ldquo;likelihood surface&amp;rdquo;.
For a model with 2 parameters, we can easily visualize that surface in a single plot.
When a model has $p$ parameters there are $p$ dimensions to the likelihood surface.
Minimizing the negative log-likelihood to obtain the parameter MLEs is equivalent to finding the lowest point of that surface.
Doing so is not a problem when the surface is like a smooth, unimodal, round bowl shape with only one well-defined minimum point,
but such a shape is far from guaranteed for all models and datasets.
In fact, depending on the data and/or the model, a likelihood surface could exhibit many shapes that are different from that of a (multidimensional) bowl.&lt;/p&gt;
&lt;p&gt;The shape of the likelihood surface relates to issues of parameter- (and model-) identifiability,
and to attempts to quantify parameter uncertainty.&lt;/p&gt;
&lt;h3 id=&#34;par_ident&#34;&gt;Identifiability&lt;/h3&gt;
&lt;p&gt;The likelihood surface could be wavy and have multiple minima.
In that case our optimizer could potentially get stuck in a &lt;em&gt;local&lt;/em&gt; minimum,
unable to find the true MLE associated with the &lt;em&gt;global&lt;/em&gt; (lowest) minimum.
Different optimizers attempt to deal with this potential problem in different ways, but as alluded to above, it is often wise to start at different initial parameter values to confirm convergence to the same optimum.&lt;/p&gt;
&lt;p&gt;The surface could be relatively flat in one or more parameters.
The reasons for this include that there may be insufficient information in the data to constrain the values of the parameter(s) (i.e. all values are similarly likely);
a parameter&amp;rsquo;s MLE would thus come with large uncertainty.&lt;/p&gt;
&lt;p&gt;The surface could be relatively or even entirely flat for some combination of parameters.
This could happen because the model (or the data) are structured in such a way that two or more parameters are not (sufficiently) identifiable.
That is, parameters (or covariates) may co-vary in such a way that their independent effects cannot be distinguished.
In two-dimensions, this would look like a likelihood surface that has a valley running through it.
Each individual parameters apparent MLE could thus appear to be well-constrained (i.e. appear to have low uncertainty), but there could nonetheless be considerable uncertainty in their values.&lt;/p&gt;
&lt;p&gt;My sense is that likelihood surfaces with multiple minima most commonly occur for datasets that are too small for the task.
For small data sets, noise predominates and different parameter combinations fit different data points similarly well.&lt;/p&gt;
&lt;p&gt;Flat surfaces or surfaces with valleys, on the other hand, will not be resolved simply by having more data (if it is similar to the data already available).
Rather, what is typically needed is either more information and/or an alternatively formulated model structure.
More information can come from better-designed &amp;rsquo;experiments&amp;rsquo; that, for example,
(i) increase the range of values that the predictor variables exhibit (e.g., beyond what is &amp;ldquo;natural&amp;rdquo;), and
(ii) increase the independence (decreases the co-variation) among predictor variables.
Examples of alternative model structures include
(i) replacing two parameters that always co-occur as a product by a single compound parameter, and
(ii) rewritting a model in a mathematically equivalent (but statistically non-equivalent) formulation
(e.g., the Holling Type II versus the Michaelis-Menten models).
That said, these are relatively extreme, simple examples that represent a range of potential issues and solutions relating to identifability that you may encounter and where expert experience is often required.&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/lik_bowl-1.png&#34; width=&#34;768&#34; style=&#34;display: block; margin: auto;&#34; /&gt;
&lt;h3 id=&#34;quantifying-uncertainty&#34;&gt;Quantifying uncertainty&lt;/h3&gt;
&lt;p&gt;When our goal is to make comparisons of model performance using information criteria,
then all we need from model fitting are the values of each model&amp;rsquo;s minimum negative log-likelihood associated with their parameter MLEs.
However, many times we&amp;rsquo;re not only interested in just doing model comparison or just obtaining the MLE values of the parameters.
Rather, we often would also like to characterize the statistical uncertainty (&amp;ldquo;clarity&amp;rdquo;) of the parameter estimates.
The most common way to do that is by determining the 95% confidence intervals of the MLEs.&lt;/p&gt;
&lt;p&gt;For that, we&amp;rsquo;ll make use of the &lt;code&gt;mle2()&lt;/code&gt; and &lt;code&gt;confint()&lt;/code&gt; functions from the &lt;code&gt;bbmle&lt;/code&gt; package. &lt;code&gt;mle2()&lt;/code&gt; uses &lt;code&gt;optim()&lt;/code&gt; as the default optimizer to determine the parameter MLEs, and &lt;code&gt;confint()&lt;/code&gt; takes the result and returns the parameter confidence intervals.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;ll continue on with the small $n=10$ dataset we generated when we demonstrated the fitting of the $f_1$ model.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;data.frame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;P&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;round&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;##       P  k
## 1  26.6  6
## 2  37.2  9
## 3  57.3 22
## 4  90.8 33
## 5  20.2  6
## 6  89.8 33
## 7  94.5 26
## 8  66.1 18
## 9  62.9 19
## 10  6.2  1
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;library&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bbmle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;nlL.pois.f1.bbmle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dpois&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;log&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;TRUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;fit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mle2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nlL.pois.f1.bbmle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## 
## Call:
## mle2(minuslogl = nlL.pois.f1.bbmle, start = list(a = 0.2))
## 
## Coefficients:
##         a 
## 0.3136831 
## 
## Log-likelihood: -24.37
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;confint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;##     2.5 %    97.5 % 
## 0.2692366 0.3627788
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice that&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mle2()&lt;/code&gt; wants the negative log-likelihood function to have (all) the parameters as arguments (unlike &lt;code&gt;optim()&lt;/code&gt; which wanted a single &lt;code&gt;par&lt;/code&gt; argument containing the parameters);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mle2()&lt;/code&gt; has the order of the arguments for the negative log-likelihood and the list of initial parameter values reversed relative to &lt;code&gt;optim()&lt;/code&gt;; and&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mle2()&lt;/code&gt; returns the (positive) log-likelihood rather than the negative log-likelihood. (I don&amp;rsquo;t know why.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;code&gt;bbmle&lt;/code&gt; package also has several other potentially useful functions that we won&amp;rsquo;t get into.
Note that the above code is included at the bottom of &lt;a href=&#34;https://models4data2theory.github.io/courses_Rscripts/ModelFitting_3.R&#34;&gt;ModelFitting_3.R&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;end_result&#34;&gt;End result&lt;/h2&gt;
&lt;p&gt;We used our visitation count data (introduced at the very start) to fit three models relating visitation rates to plant density.
These models had either one, two, or three biologically-reasoned parameters that enabled the models to describe different types of relationships between observed visitation counts and plant density:  linear, saturating, and sigmoid.
The three models therefore reflected different expectations/hypotheses about the deterministic biological processes that could have generated the data,
but in fitting them we also attempted to stay true to the likely stochastic processes that introduced noise to the data.&lt;/p&gt;
&lt;p&gt;The results of our efforts are as follows:&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_interactions_files/figure-html/endresult_fit-1.png&#34; width=&#34;384&#34; /&gt;
&lt;p&gt;We obtained maximum likelihood point estimates and their 95% confidence intervals for each of the three models.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## [1] &amp;#34;f1 parameters&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;##  est.a  2.5 % 97.5 % 
##  0.276  0.262  0.289
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## [1] &amp;#34;f2 parameters&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;##     est 2.5 % 97.5 %
## a 0.485 0.412  0.576
## h 0.021 0.016  0.026
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## [1] &amp;#34;f3 parameters&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;##         est 2.5 % 97.5 %
## a     0.044 0.010  0.161
## h     0.038 0.031  0.043
## theta 1.812 1.385  2.310
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Comparing the performance of the three models using &lt;em&gt;AIC&lt;/em&gt;,
we conclude that there is &amp;ldquo;substantial&amp;rdquo; support for model $f_3$ over the other two models.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;##        AIC   dAIC  df
## fit.f3 538.4   0.0 3 
## fit.f2 552.0  13.6 2 
## fit.f1 613.1  74.7 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Jump back to the &lt;a href=&#34;#overview&#34;&gt;Overview section&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;final-thoughts&#34;&gt;Final thoughts&lt;/h2&gt;
&lt;p&gt;There is much that we have only touched on and even more we have swept under the rug, but hopefully we&amp;rsquo;re leaving you with a good enough starting point for your own interests.
Most importantly, don&amp;rsquo;t get discouraged or frustrated by the challenge that model fitting can be.
The process of model fitting has often been described as an &amp;ldquo;art&amp;rdquo;.
It is a skill that is learned through practice and accumulated experience, and therefore through perseverance.
And it&amp;rsquo;s worth pointing out that it&amp;rsquo;s a skill to be learned not only in regards to statistical and mathematical knowledge and comfort
(e.g., experience with probability distributions and deterministic functions, respectively),
but also in terms of empirical knowledge of the data and the biological (and data collection) processes that are likely responsible for having generated the data.
Statisticians and mathematicians have just as hard a time thinking about biology as biologists do with the statistics and math!
It&amp;rsquo;s in the challenge of gaining a balanced expertise in all three where the fun and excitement lies.&lt;/p&gt;
&lt;h2 id=&#34;readings&#34;&gt;Readings&lt;/h2&gt;
&lt;p&gt;Aho, Derryberry, and Peterson (2014) Model selection for ecologists: the worldviews of AIC and BIC. Ecology, 95(3):631–636&lt;/p&gt;
&lt;p&gt;Bolker (2008) Ecological models and data in R. Princeton University Press&lt;/p&gt;
&lt;p&gt;Höge, Wöhling, and Nowak (2018) A primer for model selection: The decisive role of model complexity. Water Resources Research, 54(3):1688–1715&lt;/p&gt;
&lt;p&gt;Murtaugh (2014) In defense of p values. Ecology, 95(3):611–617&lt;/p&gt;
&lt;p&gt;Novak and Stouffer (2021) Geometric complexity and the information-theoretic comparison of functional-response models. Frontiers in Ecology and Evolution, 9:776&lt;/p&gt;
&lt;p&gt;Novak and Stouffer (2021) Systematic bias in studies of consumer functional responses. Ecology Letters, 24(3):580–593&lt;/p&gt;
&lt;h2 id=&#34;solutions&#34;&gt;Solutions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://models4data2theory.github.io/courses_Rscripts/ModelFitting_1.R&#34;&gt;ModelFitting_1.R&lt;/a&gt; (no &amp;lsquo;key&amp;rsquo;)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://models4data2theory.github.io/courses_Rscripts/ModelFitting_2_key.R&#34;&gt;ModelFitting_2_key.R&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://models4data2theory.github.io/courses_Rscripts/ModelFitting_3_key.R&#34;&gt;ModelFitting_3_key.R&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://models4data2theory.github.io/courses_Rscripts/ModelFitting_4.R&#34;&gt;ModelFitting_4_key.R&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;session-info&#34;&gt;Session Info&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;sessionInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## R version 4.4.1 (2024-06-14)
## Platform: aarch64-apple-darwin20
## Running under: macOS Sonoma 14.5
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib 
## LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## time zone: America/Los_Angeles
## tzcode source: internal
## 
## attached base packages:
## [1] stats4    stats     graphics  grDevices utils     datasets  methods  
## [8] base     
## 
## other attached packages:
## [1] bbmle_1.0.25.1
## 
## loaded via a namespace (and not attached):
##  [1] cli_3.6.3           knitr_1.48          rlang_1.1.4        
##  [4] xfun_0.47           highr_0.11          jsonlite_1.8.8     
##  [7] htmltools_0.5.8.1   sass_0.4.9          rmarkdown_2.28     
## [10] grid_4.4.1          evaluate_0.24.0     jquerylib_0.1.4    
## [13] MASS_7.3-61         fastmap_1.2.0       mvtnorm_1.2-6      
## [16] yaml_2.3.10         lifecycle_1.0.4     numDeriv_2016.8-1.1
## [19] bookdown_0.40       compiler_4.4.1      rstudioapi_0.16.0  
## [22] blogdown_1.19       lattice_0.22-6      digest_0.6.37      
## [25] R6_2.5.1            bslib_0.8.0         Matrix_1.7-0       
## [28] tools_4.4.1         bdsmatrix_1.3-7     cachem_1.1.0
&lt;/code&gt;&lt;/pre&gt;&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Note that you&amp;rsquo;ll more typically see the probability of the binomial written as $P(k |n, p)$ with $n$ treated as a parameter rather than a known variable, but we&amp;rsquo;re going to use $P(k, n|p)$ since $k$ and $n$ both come from data to better contrast probabilities with likelihoods.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Some of you may know (or notice in the lefthand figure) that it&amp;rsquo;s possible for $Pr(k | \lambda) = Pr(k-1 | \lambda )$ (i.e. there is no single maximum to the probability mass function $Pr(k | \lambda)$) &lt;em&gt;when $\lambda$ is an integer&lt;/em&gt;. (See &lt;a href=&#34;https://math.stackexchange.com/questions/4144800/poisson-distribution-with-an-integer-lambda-value&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this StackExchange post&lt;/a&gt; for an explanation.)
However, this is &lt;em&gt;not&lt;/em&gt; the case for the likelihood function (i.e. there is a single maximum) when we plot the likelihood as a function of the parameter (as shown in the righthand figure).&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;By convention we use the natural logarithm, $\ln = \log_{e}$.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;For simple models, the likelihood will typically only have one minimum and no maximum (or maxima) to worry about.  But we&amp;rsquo;ll come back to this below.&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;code&gt;optim()&lt;/code&gt; will work in one-dimensional (single-parameter) situations, as we are working with at present, but the default &lt;code&gt;Nelder–Mead&lt;/code&gt; method that works very well in most higher-dimensional situations often does not work well for one-dimensional situations and thus issues a warning.&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;We here focus on theoretical models that generate predictions for the &lt;em&gt;expected&lt;/em&gt; value (the mean) of the response variable as a function of the covariate(s).
These are by far the most common type of theoretical models. However, there are models that generate predictions for the variance, etc. as well, which can be just as useful in fitting models to data through the choice of appropriate probability distributions (i.e. likelihood functions).
As noted above, the mean and variance of the Poisson are in fact the same, and they are entirely dependent for the binomial, so we are making &amp;mdash; and making use of &amp;mdash; that assumption when we&amp;rsquo;re fitting out data with them.&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&amp;hellip;when visitation rates are expressed on a &lt;em&gt;per pollinator&lt;/em&gt; basis!   For our exercise, we can think of having arbitrarily set the pollinator abundance to $A=1$ for all visitation counts. In an empirical dataset the total number of visits would be $f(P) \cdot A$ and we&amp;rsquo;d have to supply the vector of pollinator abundances to our likelihood function as well.&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;The model is also called the &lt;em&gt;generalized Holling Type III&lt;/em&gt;.  The original two-parameter &lt;em&gt;Holling Type III&lt;/em&gt; has $\theta = 2$ corresponding to a search rate that increases linearly with $P$.&amp;#160;&lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Recall that, for simplicity, we&amp;rsquo;re here assuming that the number of pollinators is constant across all our observations.&amp;#160;&lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:10&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;This touches on issues central to an active discussion between and within the worlds of statistics and machine learning.&amp;#160;&lt;a href=&#34;#fnref:10&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:11&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Also note that the literature often uses $k$ to represent the count of the parameters.  We&amp;rsquo;ll use $p$ here to avoid confusion with our prior usage of $k$ as the count of pollinator visits.&amp;#160;&lt;a href=&#34;#fnref:11&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:12&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;The issues are similar to those involved in how to evaluate &amp;ldquo;significance&amp;rdquo; using p-values.&amp;#160;&lt;a href=&#34;#fnref:12&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:13&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;For linear models this cutoff has been shown to correspond closely to considering a $p &amp;lt; 0.05$ to be statistically &amp;ldquo;significant&amp;rdquo;.&amp;#160;&lt;a href=&#34;#fnref:13&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
    <item>
      <title>Dynamics</title>
      <link>https://models4data2theory.github.io/courses/wkshp_dynamics/</link>
      <pubDate>Fri, 23 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://models4data2theory.github.io/courses/wkshp_dynamics/</guid>
      <description>&lt;p&gt;&lt;em&gt;Dynamics and stability&lt;/em&gt;&lt;/p&gt;
&lt;!-- ## Motivation --&gt;
&lt;!-- ## Overview {#overview} --&gt;
&lt;p&gt;Throughout, we will use the symbol &lt;strong&gt;$N$&lt;/strong&gt; to represent population size, as it does in nearly all population models in ecology.&lt;/p&gt;
&lt;p&gt;For a start preceding the introduction of exponential growth, see the &lt;a href=&#34;https://models4data2theory.github.io/potential_use_or_interest&#34;&gt;Of Potential Interest&lt;/a&gt; page.&lt;/p&gt;
&lt;h2 id=&#34;required-r-packages&#34;&gt;Required R-packages&lt;/h2&gt;
&lt;p&gt;We&amp;rsquo;ll need the &lt;code&gt;deSolve&lt;/code&gt; package to integrate our differential equations with respect to time.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# install.packages(&amp;#39;deSolve&amp;#39;, dependencies = TRUE) # use to install if needed&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;library&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;deSolve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;exponential-growth&#34;&gt;Exponential growth&lt;/h2&gt;
&lt;p&gt;We will take as our starting point the differential equation,&lt;/p&gt;
&lt;p&gt;$$
\frac{dN}{dt} = rN .
$$
The left-hand-side of this equation is little more than a tangent slope: the change in population size given a change in time (i.e. how much the population size changes over a small amount of time).&lt;/p&gt;
&lt;!-- $$ --&gt;
&lt;!-- \frac{dN}{dt} = \lim_{\Delta t \rightarrow 0} \frac{N_{t+\Delta t} - N_t}{\Delta t} = \lim_{\Delta t \rightarrow 0}\frac{\Delta N}{\Delta t}, --&gt;
&lt;!-- $$ --&gt;
&lt;p&gt;The right hand size is a product of the population size $N$ (at any given instant in time) and $r$ is the intrinsic &lt;em&gt;per capita&lt;/em&gt; growth rate.
The intrinsic growth rate is nothing more than the difference between the rate at which the average individual gives birth, $b$, and the rate at which the average individual die, $d$.
Together, they left and right-hand sizes of the equation represent the model of &lt;strong&gt;exponential growth&lt;/strong&gt;.&lt;/p&gt;
&lt;!-- It&#39;s also exactly equivalent to the first expression of change in population size over time (as it should be): $\frac{dN}{dt} = rN$ and since $r = \frac{(b-d)}{N}$, with substitution: $\frac{dN}{dt} = \frac{(b-d)}{N}N$; the $N$s cancel so we are left with our original equation: $\frac{dN}{dt} = b - d$. --&gt;
&lt;!-- Note that if the total number of births and deaths are equal, then $r = 0$ and $\frac{dN}{dt} = 0$, meaning the *rate of change* in the population is zero---in other words, the population is at equilibrium. Importantly, that does *not* mean that the population size is zero. --&gt;
&lt;p&gt;The key to the exponential model is that the &lt;em&gt;per capita&lt;/em&gt; birth and death rates (and thus $r$) are themselves independent of $N$.
As a result, the population will growth if $r$ is net positive ($b &amp;gt; d$) and will exhibit exponential growth.
Conversely, the population will shrink if $r$ is net negative ($b &amp;lt; d$) and will exhibit exponential decay.&lt;/p&gt;
&lt;h3 id=&#34;projections&#34;&gt;Projections&lt;/h3&gt;
&lt;p&gt;To use the differential equation $\frac{dN}{dt}=rN$ to project population sizes into the future we need to &lt;em&gt;integrate&lt;/em&gt; the differential equation.
Integrating from time $0$ to some time $T$ in the future, and assuming an initial population size at time zero of $N_0$, we get:&lt;/p&gt;
&lt;p&gt;$$
\int_0^T \frac{dN}{dt} dt = \int_0^T r N dt \implies N_T = N_0e^{rT},
$$
where $e$ is Euler&amp;rsquo;s number aka the base of the natural logarithm, which rounded to 5 digits is: 2.71828.
(Think of Euler&amp;rsquo;s number $e$ as the anti-logarithm $ln$ or $log_e$, just like $2^x$ is the anti-logarithm of $log_2$.)
Euler&amp;rsquo;s number is deeply rooted to multiplicative (exponential) processes.&lt;br&gt;
The fact that an exponential shows up in the equation is why the modelis referred to as the model of exponential growth.&lt;/p&gt;
&lt;!-- The expression above allows you to find the exact value of the population size at any timestep in the future if you know the starting value of the population $N_0$ and $r$. For example, if we want to find population size in 4 years ($t = 4$), for a population with a currently size of 100 ($N_0 = 100$) and $r = 1.1$, we get: --&gt;
&lt;!-- $N_4 = 100 \times e^{(1.1 \times 4)}$; thus $N_4 = 100 \times e^{4.4}$; $e^{4.4} = 81.45087$, so $N_4 = 100 \times 81.45087$, and thus $N_4 = 8145.087$ --&gt;
&lt;!-- here is one way you could model this in R, calculating that exact value over a time range with a simple `for()` loop. We&#39;ll use a starting population size $N_0$ of 12, and $r$ = 0.2: --&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_dynamics_files/figure-html/exponential growth N_0e^rt-1.png&#34; width=&#34;672&#34; /&gt;
&lt;!-- This looks as we expect intuitively: the population is increasing exponentially. --&gt;
&lt;h3 id=&#34;integration&#34;&gt;Integration&lt;/h3&gt;
&lt;p&gt;Analytically integrating $\frac{dN}{dt}$ to obtain a projection equation for the exponential model is relatively straightforward.
Doing so is also possible for other models, such as the Logistic model that we will look at next.
However, for most population dynamic models in ecology (especially multi-species models), analytical integration isn&amp;rsquo;t possible.
So what we want to do is to develop a platform for modeling population dynamics that allows us to numerically solve integration problems (i.e. solve with calculations done by the computer rather than analytically), in a way that is extensible to much more complex problems.
And to learn such approaches, it is definitely best to start with a simple model&amp;mdash;and the extremely simple exponential growth model is perfect for this.&lt;/p&gt;
&lt;p&gt;The tool we will work with is the &lt;code&gt;ode()&lt;/code&gt; function of the &lt;code&gt;deSolve&lt;/code&gt; package.
&lt;code&gt;deSolve&lt;/code&gt; implements multiple different numerical methods for solving ODEs (ordinary differential equations), which are the kinds of equations we will be working with in this workshop
(equations that have $\frac{dN}{dt}$ on the left-hand side).
The &lt;code&gt;deSolve&lt;/code&gt; package is very powerful and allows us to numerically solve even very complex multi-species network models (which we will be working up to throughout the day).
But that flexibility means that it has a complex structure, which can admittedly be somewhat confusing when you are first starting to use it.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;ode()&lt;/code&gt; requires a minimum of four input arguments, &lt;code&gt;ode(y, times, func, parms)&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; is initial starting size of the variable (i.e. $N(0)$)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;times&lt;/code&gt; are the vector of time points $t$ at which we want &lt;code&gt;ode&lt;/code&gt; to spit out the values of $N(t)$
&lt;ul&gt;
&lt;li&gt;e.g., &lt;code&gt;times = 1:100&lt;/code&gt; or &lt;code&gt;times = seq(from = 1, to = 200, by = 0.2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;func&lt;/code&gt; is our ODE model for $dN/dt$ (written as a function with its own arguments)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parms&lt;/code&gt; is a vector of the ODE model&amp;rsquo;s named parameters&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The argument &lt;code&gt;func&lt;/code&gt; (i.e. our ODE model) that we provide &lt;code&gt;ode&lt;/code&gt; must be defined in a particular way that may feel a little redundant with the input that we pass to the &lt;code&gt;ode&lt;/code&gt; function because they have to be working in parallel.
The arguments that the function must have are (in order): (1) times; (2) the variable(s)&amp;mdash;here, population size; and (3) the parameters used in our model.&lt;/p&gt;
&lt;p&gt;In our code below, we will also take advantage of a facet of R that is not very well known.
You can create a vector in R where you name the elements, for example &lt;code&gt;my.vector = c(marmot = 3.2, pika = 47.6, ground.squirrel = 18.4)&lt;/code&gt;.
With a named vector, you can then access the elements via their name indicated with quotation marks:
for the example above if you entered &lt;code&gt;my.vector[&#39;pika&#39;]&lt;/code&gt; you would get back &lt;code&gt;47.6.&lt;/code&gt;
We can use that with our parameters to clearly name which parameter is which.
Here we really just have one parameter (&lt;code&gt;r&lt;/code&gt;) and one response / output variable (&lt;code&gt;N&lt;/code&gt;), but still, it is useful to name them &lt;code&gt;parameters &amp;lt;- c(r = 0.2)&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;lets-try-it&#34;&gt;Let&amp;rsquo;s try it&lt;/h3&gt;
&lt;p&gt;We&amp;rsquo;ll use the exact same setup in terms of values of $r$ and $N(0)$ as we did in the plot above.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# library(deSolve)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# set initial conditions of response variable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;popn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Parameters&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;parameters&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Time sequence&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;times&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;seq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;by&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# &amp;#34;exp.model&amp;#34; stands for &amp;#34;exponential growth model&amp;#34; &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;exp.model&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;popn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parameters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# exponential growth model, dNdt = r*N:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dNdt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parameters[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;popn[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# the function must return a list (even if it is just one element):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dNdt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Solve the ODE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;popn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;times&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;times&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exp.model&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parameters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Plot the output&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;plot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ylab&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;population size, N&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;col&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;blue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_dynamics_files/figure-html/exponential growth-1.png&#34; width=&#34;672&#34; /&gt;
&lt;p&gt;Great&amp;mdash;this looks identical to our previous plot, which is what we wanted.
If you view it with &lt;code&gt;View(out)&lt;/code&gt; you can see that there are two columns in the output from &lt;code&gt;ode&lt;/code&gt;, one for time and one for population size.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise:&lt;/strong&gt;
Alter the code above to run a simulation of exponential growth over 200 time steps, for a population with an initial size of 202 individuals and $r$ = 0.225.&lt;/p&gt;
&lt;!-- **optional:** write a `for` loop (or a vectorized version, e.g. with one of the `apply` functions) to calculate population growth with the same parameters but with a difference equation (not a differential equation) approach. Plot both curves on the same graph to show how the differential equation gives us the (true) faster growth relative to a difference equation. --&gt;
&lt;h2 id=&#34;logistic-growth&#34;&gt;Logistic growth&lt;/h2&gt;
&lt;p&gt;As discussed above, the exponential growth model approximates reality by assuming that per-capita birth and death rates are &lt;em&gt;constant&lt;/em&gt;&amp;mdash;an individual has a set number of offspring and a fixed chance of dying over a given time period.
If you are competing with lots and lots of conspecifics to get enough food, or you&amp;rsquo;re under heightened risk of disease, it&amp;rsquo;s likely that your chance of dying in a given time will go up, and that the number of offpsring you produce will go down.
There are many different empirical datasets from around the world and a range of different kinds of organisms (plants, animals, microbes, etc.) showing this pattern of &lt;em&gt;negative density-dependence&lt;/em&gt;&amp;mdash;in other words, $r$ is not a constant with respect to population size, but instead changes as a function of population size.&lt;/p&gt;
&lt;p&gt;To model density-dependent growth, we&amp;rsquo;ll start from the exponential growth equation, which again, is:&lt;/p&gt;
&lt;p&gt;$$
\frac{dN}{dt} = rN  .
$$&lt;/p&gt;
&lt;p&gt;If we divide both sides by $N$, we get&lt;/p&gt;
&lt;p&gt;$$
\frac{1}{N}\frac{dN}{dt} = r .
$$&lt;/p&gt;
&lt;p&gt;The left-hand side $\left( \frac{1}{N}\frac{dN}{dt} \right)$ we have the term for per-capita population growth rate, and on the right hand side we have $r$ (which we are again here defining as a constant).
This equation may strike you as almost tautological, since we defined $r$ as the per-capita population growth rate, but perhaps another way to think of it is that it is reassuring that re-arranging the equation brings us back to our definitional equalities.&lt;/p&gt;
&lt;p&gt;The point here is that we have re-arranged things to have the per-capita population growth rate on the left (as the response variable), and a constant on the right.
Now we can change the right-hand side from a constant to some function of population size to reflect density dependence.&lt;/p&gt;
&lt;p&gt;One of the simplest way to incorporate density dependence is to assume that $\left( \frac{1}{N}\frac{dN}{dt} \right)$ is a &lt;em&gt;linear&lt;/em&gt; function of density;
this ultimately yields the &lt;em&gt;logistic growth equation&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In formulating linear density dependence, the hypothetical &lt;em&gt;maximum&lt;/em&gt; possible per-capita population growth rate  occurs when the population is approaching zero (i.e., no possible density effects);
obviously that value would never be realized if the population were actually zero, so think about $\left( \frac{1}{N}\frac{dN}{dt} \right)$ as approaching $r$ as $N$ tends towards 0.
A line with a negative slope (decreasing function of $N$) would at some point then cross the $N$-axis, at which point the per-capita population growth rate would be zero;
and would keep going down as the population size increases (at which point the per-capita populationgrowth rate would be &lt;em&gt;negative&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Here is what such a linear formulation would look like:&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_dynamics_files/figure-html/logistic growth graphical representation-1.png&#34; width=&#34;672&#34; /&gt;
&lt;p&gt;Next, we will re-define $\left( \frac{1}{N}\frac{dN}{dt} \right)$.
In our formulation of the exponential growth model, $r$ was the constant or fixed per-capita population growth rate.
Now, we will set $r$ to be the (intrinsic) &lt;em&gt;maximum&lt;/em&gt; population growth rate in the absence of competition.
In other words, $r$ is the &lt;em&gt;y&lt;/em&gt;-intercept of the graph above.&lt;/p&gt;
&lt;p&gt;We can also define the $N$-intercept of the line. Population biologists call the $N$-intercept the &lt;em&gt;carrying capacity&lt;/em&gt;, $K$.
At the carrying capacity, then, is where the population stops changing in population size, since the per-capita population growth rate is (net) zero.
Births and deaths are still happening, but they cancel each other out; all deaths are replaced by an equal number of births.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s add those labels to our plot:&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_dynamics_files/figure-html/logistic growth graphical derivation-1.png&#34; width=&#34;672&#34; /&gt;
&lt;p&gt;With those definitions in mind, let&amp;rsquo;s get back to our task of setting the per-capita population growth rate $\frac{dN}{dt}\frac{1}{N}$ to the linear function above, using the generic formula for a line of $y = m x + b$:&lt;/p&gt;
&lt;p&gt;$$
\frac{1}{N}\frac{dN}{dt} =  r - \frac{r}{K} N,
$$
where we have replaced
$x \rightarrow N$,
$b \rightarrow r$ is the intercept,
and $m \rightarrow -\tfrac{r}{K}$ is the slope.
The slope ($m$), is defined as &amp;ldquo;rise&amp;rdquo; (change in the &lt;em&gt;y&lt;/em&gt;-axis) over &amp;ldquo;run&amp;rdquo; (change in the &lt;em&gt;x&lt;/em&gt;-axis).
As the population moves on the &lt;em&gt;x&lt;/em&gt;-axis from 0 to $K$, the per capita growth rate changes from $r$ to 0.
Thus, the &amp;ldquo;rise&amp;rdquo; is $-r$ and the &amp;ldquo;run&amp;rdquo; is $K$, so $m = \frac{-r}{K}$.&lt;/p&gt;
&lt;p&gt;Rearranging by factoring out $r$, we have
$$
\frac{dN}{dt}\frac{1}{N} = r\left(1 - \frac{N}{K}\right)
$$
and thus, reverting to thinking about the population growth rate, we have
$$
\frac{dN}{dt} = rN\left(1 - \frac{N}{K}\right) .
$$&lt;/p&gt;
&lt;p&gt;This is the &lt;strong&gt;logistic growth equation&lt;/strong&gt; that is ubiquitous in population ecology.&lt;/p&gt;
&lt;h3 id=&#34;lets-try-it-1&#34;&gt;Let&amp;rsquo;s try it&lt;/h3&gt;
&lt;p&gt;We&amp;rsquo;ll model logistic growth using &lt;code&gt;deSolve&lt;/code&gt; as we did above for exponential growth.
We actually don&amp;rsquo;t have to change very much;
the time part is the same and we still keeping track of just one population.
We&amp;rsquo;ll need to change the formulation of the model itself, of course, and add parameter $K$ to the parameter vector.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# library(deSolve)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# set initial conditions of response variable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;popn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Parameters&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# only change from exponential is adding `K`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;params&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;K&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;250000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Time sequence&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;times&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;seq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;by&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# function for ode&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;logistic.model&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;popn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parameters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# logistic growth equation:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dNdt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;params[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;popn[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;popn[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;params[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#39;K&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dNdt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Solve the ODE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;popn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;times&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;times&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logistic.model&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;parms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Plot the output&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;plot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;ylab&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;population size, N&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;col&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;blue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_dynamics_files/figure-html/logistic growth-1.png&#34; width=&#34;672&#34; /&gt;
&lt;p&gt;Again, looks good&amp;mdash;we see what we expect, which is that the population grows exponentially initially, but as the population increases, that growth slows down until it plateaus out at the steady state value of $K = 250,000$.&lt;/p&gt;
&lt;h3 id=&#34;compact-code&#34;&gt;Compact code&lt;/h3&gt;
&lt;p&gt;For the code above, we have just three input values that need specifying: the population size $N$ (a variable), and two fixed parameters: the (maximum) per-capita population growth rate $r$ and the carrying capacity $K$.
The code above refers to different places where we could find those input values (separating the variable from the parameters), and it works well enough.&lt;/p&gt;
&lt;p&gt;But we can make the coding a little easier on ourselves&amp;mdash;and perhaps more importantly, more transparent and scalable&amp;mdash;with just a little bit of additional code &amp;ldquo;magic&amp;rdquo;.
The code chunk below does the same thing as the code above, but the code for the model itself is much more compact and streamlined, using the variable / parameter names themselves (e.g., &lt;code&gt;r&lt;/code&gt;) rather than having to reference the name of the object in which to look for those (e.g. &lt;code&gt;params[&#39;r&#39;]&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Again, for exponential or logistic growth, it isn&amp;rsquo;t a very big deal to have to include the name of an object like &lt;code&gt;params&lt;/code&gt;, but as our models become more complicated, it makes our life much easier to just include the name of the variables. We can do that with the addition of just a single line of code:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;with(as.list(c(popn, params)), {...})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This line of code allows us to &lt;em&gt;directly use the names of the variables and parameters&lt;/em&gt; in the objects (&lt;code&gt;popn&lt;/code&gt; and &lt;code&gt;params&lt;/code&gt;) that we included in that argument&amp;mdash;and we could pass along as many objects as we wanted, making sure that the values within them are named, e.g. &lt;code&gt;params &amp;lt;- c(r = 0.2, K = 250000)&lt;/code&gt;, but &lt;em&gt;not&lt;/em&gt; &lt;code&gt;params &amp;lt;- c(0.2, 250000)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To break down that line of code function-by-function:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c()&lt;/code&gt; combines the two vectors (&lt;code&gt;popn&lt;/code&gt; and &lt;code&gt;params&lt;/code&gt;) into a single vector (you could include as many vectors here as you would like)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as.list&lt;/code&gt; turns that vector into a list (which is what the next argument, &lt;code&gt;with&lt;/code&gt; requires)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;with&lt;/code&gt; is the real &amp;ldquo;magic&amp;rdquo;: it creates an environment from that list, within which R looks for &lt;em&gt;named&lt;/em&gt; values&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The ellipses (&lt;code&gt;{...}&lt;/code&gt;) in the curly braces in the line of code above signal that we have to include the code for model itself &lt;em&gt;inside&lt;/em&gt; the arguments to &lt;code&gt;with()&lt;/code&gt; and specifically within the curly braces&amp;mdash;see below for how that is done, usually across multiple lines of code.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a look at how that is actually implemented.
The key difference between the code chunk below and the one above is that we can now specify our model much more directly, compactly, and readably:
&lt;code&gt;dNdt &amp;lt;- r*N*(1 - N/K)&lt;/code&gt; rather than &lt;code&gt;dNdt &amp;lt;- params[&#39;r&#39;] * popn[&#39;N&#39;] * (1 - popn[&#39;N&#39;] / params[&#39;K&#39;])&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# library(deSolve)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# set initial condition (at time zero) of our response variable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;popn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Parameters&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;params&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;K&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;250000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Time sequence&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;times&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;seq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;by&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# specify the model&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;logistic.model&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;popn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parameters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# `with` line tells code where to find the named elements in the model&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;with&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;as.list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;popn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# logistic growth equation--very transparent!:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dNdt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# again, for `ode` need to return a list, even if it&amp;#39;s just a vector&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dNdt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Solve the ODE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;popn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;times&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;times&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logistic.model&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;parms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Plot the output&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;plot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;ylab&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;population size, N&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;col&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;blue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_dynamics_files/figure-html/logistic growth using with-1.png&#34; width=&#34;672&#34; /&gt;
&lt;p&gt;As hoped, we get back exactly the same graph as with our prior code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise&lt;/strong&gt;
Run the logistic growth code above, and then re-run it with a much larger value of $r$ of your choice, but less than $r = 2$ (keep $K$ the same).
Re-name the variable &lt;code&gt;out&lt;/code&gt; when you re-run it so you have access to the data from both runs.
Plot both curves on the same graph, with two different colors.&lt;/p&gt;
&lt;!-- **optional exercise:** An alternative formulation of the logistic growth equation is to define $\alpha = 1 / K$, where $\alpha$ is the per-capita effect of one individual on the growth rate of the population. We can then substitute $\alpha$ that back into the classic logistic growth equation we defined above: --&gt;
&lt;!-- $$ --&gt;
&lt;!-- \frac{dN}{dt} = rN(1 - \alpha N) --&gt;
&lt;!-- $$ --&gt;
&lt;!-- Using the same starting value of $N$ and same values of $r$ and $K$,  --&gt;
&lt;!-- write code with `deSolve` for this formulation of the logistic growth equation.  --&gt;
&lt;!-- You should get a graph back that is identical to the ones above. --&gt;
&lt;h2 id=&#34;stability&#34;&gt;Stability&lt;/h2&gt;
&lt;h3 id=&#34;steady-states&#34;&gt;Steady states&lt;/h3&gt;
&lt;p&gt;The steady-state abundance for a differential equation $f(N)=\frac{dN}{dt}$ is the value $N^&lt;em&gt;$ where $f(N^&lt;/em&gt;)=0$ (i.e. the special population size $N^*$ where the population growth rate is zero).
Births and deaths are still happening, but they cancel each other out; the system is at equilibrium.&lt;/p&gt;
&lt;p&gt;For the logistic model, there are two possible steady states (i.e. two ways to have $\frac{dN}{dt}=0$):
The (ecologically) trivial equilibrium, $N^&lt;em&gt;=0$, and the non-trivial equilibrium, $N^&lt;/em&gt;=K$.
The first of these is discernible by recognizing that everything in $f(N)$ is multiplied by $N$.
The second is solved for with some algebra:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1:&lt;/strong&gt; Set
$$
f(N)=\frac{dN}{dt}=0
$$
&lt;strong&gt;Step 2:&lt;/strong&gt; Solve for $N^&lt;em&gt;$:
$$
\frac{dN}{dt}=rN\left(1-\frac{N}{K}\right)=0
$$
$$
rN-\frac{rN^2}{K}=0
$$
$$
r =\frac{rN^2}{K}
$$
$$
N =\frac{N^2}{K}
$$
$$
NK =N^2
$$
$$
N^&lt;/em&gt;=K
$$&lt;/p&gt;
&lt;!-- #### Let&#39;s try it --&gt;
&lt;!-- Use [Dynamics_X3.R](/courses_Rscripts/Dynamics_X3.R) to investigate how the values of $r$, $K$, and $N_0$ affect the maximum value of $\frac{dN}{dt}$.\ --&gt;
&lt;!-- How does changing the value of $N_0$ affect the final equilibrium population size? --&gt;
&lt;h3 id=&#34;ball--cup&#34;&gt;Ball &amp;amp; cup&lt;/h3&gt;
&lt;p&gt;Through simulation, we found $N^&lt;em&gt;=K$ to be a &amp;ldquo;stable&amp;rdquo; in that $\underset{t \to \infty}\lim N(t) = K$ for any initial value $N$ except $N(0) = 0$.
Indeed, we found $N^&lt;/em&gt;=0$ to be &amp;ldquo;unstable&amp;rdquo;;
even an infinitesimally small value of $N(0)&amp;gt;0$ eventually got us to $K$,
with larger values of $r$ getting us there faster.&lt;/p&gt;
&lt;p&gt;To aid intuition, we can describe the driving force behind these dynamics by a landscape&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;,
with possible population sizes along the x-axis and the steepness of the landscape reflecting corresponding values of $\frac{dN}{dt}$. A ball rolling around this landscape represents any given population size.
Gravity causes the ball to roll fast when the landscape is steep (i.e. when $r$ is large), but the ball will slow down the closer it gets to $N^&lt;em&gt;$.
The equilibrium $N^&lt;/em&gt;=0$ is at the top of an inverted bowl, so any push (any &lt;em&gt;pulse perturbation&lt;/em&gt;) to it will cause the population size to roll away from 0.
Conversely, $N^*= K$ is at the bottom of a bowl, so populations that are perturbed away from $K$ will simply roll back to $K$. Intuitively, the steeper the landscape, the faster the dynamics will be (i.e. the faster the population will return to $K$).&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/wkshp_dynamics_files/figure-html/potentialLogistic-1.png&#34; width=&#34;336&#34; /&gt;
&lt;p&gt;We can evaluate these claims formally. First, by the definition of &amp;ldquo;asymptotic stability&amp;rdquo;, an equilibrium $N^&lt;em&gt;$ will be stable to a sufficiently small pulse perturbation if
$$
\lambda = \frac{df(N^&lt;/em&gt;)}{dN} &amp;lt; 0 .
$$
Recall that $f(N) = dN/dt$ and that for the logistic we have $dN/dt = r N (1- N/K)$.
Therefore we have
$$
\lambda = \frac{d}{dN}\left(rN-\frac{rN^2}{K}\right) =r-\frac{2r N}{K} = r- \frac{2r K}{K} = r-2r = -r  .
$$
This shows that $\lambda$ will be negative for any value $N^*&amp;gt;0$ as long as $r &amp;gt; 0$.
It thereby confirms our intuition that $K$ is a &lt;em&gt;stable&lt;/em&gt; equilibrium.
It also confirms our intuition that larger values of $r$ confer greater &lt;em&gt;resilience&lt;/em&gt; to the population;
it will bounce back from perturbations faster the higher its intrinstic growth rate.&lt;/p&gt;
&lt;p&gt;To preview where we&amp;rsquo;re heading, note that $-r$ is the &lt;em&gt;eigenvalue&lt;/em&gt; ($\lambda$) of $f(N^*=K)$.&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3 id=&#34;1Dstability&#34;&gt;Analysis&lt;/h3&gt;
&lt;p&gt;Why is it that $\lambda$ (i.e. the derivative of $dN/dt$ with respect to $N$ evaluated at $N^&lt;em&gt;$) tells us about the stability of $N^&lt;/em&gt;$?&lt;/p&gt;
&lt;p&gt;To understand this, let&amp;rsquo;s consider not how our population size $N$ changes in response to a small pulse perturbation but rather what happens to the size of the perturbation itself.
This will prove to be a subtle yet useful change in perspective.
If $N^*$ is indeed stable, then the size of the perturbation $x$ should shrink to zero.&lt;/p&gt;
&lt;p&gt;We can think of the size of the population immediately after the perturbation to be
$$
N(t) = N^* + x
$$
The rate of change of that population will be
$$
\frac{d  N(t)}{dt} = \frac{d (N^* + x)}{dt} = f(N^* + x)
$$
Because $N^&lt;em&gt;$ is a constant with respect to time $t$, it follows that the rate of change of the perturbation is the same. That is,
$$
\frac{d x(t)}{dt} = \frac{d N(t)}{dt} = f(N^&lt;/em&gt;+x)
$$&lt;/p&gt;
&lt;p&gt;Now that doesn&amp;rsquo;t seem to have gotten us anywhere given that $f(N^* + x)$ could be a super complicated function.
However, regardless of how complicated $f(N^* + x)$ is, we can always approximate it! We do so by using a Taylor expansion of $f(N^* + x)$ around $N^&lt;em&gt;$.
(See &lt;a href=&#34;of_potential_utility_or_interest&#34;&gt;Of Potential Utility or Interest&lt;/a&gt; page.)
That is,
$$
f(N^&lt;/em&gt; + x) = f(N^*)  + \frac{d f(N^{*})}{dN} \cdot  x + \frac{d^2 f(N^{*})}{dN^2} \cdot \frac{x^2}{2!} + + \frac{d^3 f(N^{*})}{dN^3} \cdot \frac{x^3}{3!} + \dots
$$
Notice two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;By definition, $f(N^*)=0$, so the first term drops away.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If $x$ is sufficiently small (i.e. $x &amp;laquo; 1$), then the 3rd, 4th, etc. terms are vanishingly small.&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Therefore,
$$
f(N^* + x) \approx  \frac{d f(N^&lt;em&gt;)}{dN} \cdot x
$$
which is equivalent to writing
$$
\frac{d x(t)}{dt} \approx \lambda \cdot x
$$
In other words, so long as the original perturbation $x$ is small enough, the dynamics of the perturbation will be well-approximated as a simple exponential process! If $\lambda &amp;lt; 0$, then the perturbation will exhibit exponential decay towards 0 over time and thus $N^&lt;/em&gt;$ will be &lt;em&gt;stable&lt;/em&gt;.
If $\lambda &amp;gt; 0$, then the perturbation will exhibit exponential growth and thus $N^&lt;em&gt;$ will be &lt;em&gt;unstable&lt;/em&gt;.
And if $\lambda = 0$, then the perturbation will not change in size;
$N^&lt;/em&gt;$ will then be &lt;em&gt;neutrally stable&lt;/em&gt;.
Our change in perspective to following the size of the perturbation, rather than the population itself, allowed us to do this.&lt;/p&gt;
&lt;h2 id=&#34;lv-mutualism&#34;&gt;LV Mutualism&lt;/h2&gt;
&lt;p&gt;Next, we&amp;rsquo;ll extend our single-species model of logistic growth to consider two interacting species.&lt;/p&gt;
&lt;p&gt;The Lotka-Volterra model for mutualism represents two species positively affecting the population growth rate of each other. The model assumes that the population of the two species ($N_1$ and $N_2$) grows logistically and that the interaction benefits received by the populations increases linearly with increasing population size of their mutualistic partner, which is encoded in the following equations:&lt;/p&gt;
&lt;p&gt;$$
\frac{dN_1}{dt}=r_1N_1\left(\frac{K_1-N_1+\alpha_{12}N_2}{K_1}\right)
\
\frac{dN_2}{dt}=r_2N_2\left(\frac{K_2-N_2+\alpha_{21}N_1}{K_2}\right)
$$&lt;/p&gt;
&lt;p&gt;The parameters $\alpha_{12}$ and $\alpha_{21}$ are coefficients representing the strength of mutualism.
Note that if we set them to zero (i.e. $\alpha_{12} = \alpha_{21} = 0$) we recover the logistic model for each species.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1&lt;/strong&gt;: Let&amp;rsquo;s focus just on the equation for species 1:
$$
\frac{dN_1}{dt} = r_1N_1\left(\frac{K_1-N_1+\alpha_{12}N_2}{K_1}\right) .
$$
Assume that $r_1$=0.2$\frac{1}{day}$, $\alpha_{12}$=0.5$[dimensionless]$, and $K_1$=30$\frac{indiv}{m^{2}}$.
Let&amp;rsquo;s also assume that species $N_1$ is at a density above it&amp;rsquo;s carrying capacity: $N_1=35$$\frac{indiv}{m^{2}}$. Now plug in two different values for the density of species 2: $N_2$=14$\frac{indiv}{m^{2}}$ and $N_2$=8$\frac{indiv}{m^{2}}$.
For each of these two values, solve the entire equation for the instantaneous rate of change of the population: $\frac{dN_1}{dt}$.
Is the population increasing or decreasing?
Reflect on the two outcomes, keeping in mind that species 1 was over its carrying capacity the whole time.
Do you see how this equation captures the effects of mutualism?
&lt;strong&gt;Make sure to track units when plugging numbers!&lt;/strong&gt;
Units help you to better understand models and closely track your calculations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 2&lt;/strong&gt;: Based on your calculations, reflect on how the relationship between $N$ and the carrying capacity, $K$, is affected by the population density of the mutualist species and the strength of the mutualism coefficients, $\alpha_{ij}$.
In your thinking, consider how this model captures the effects of mutualism on the fundamental niche.&lt;/p&gt;
&lt;h3 id=&#34;isoclines&#34;&gt;Isoclines&lt;/h3&gt;
&lt;p&gt;Now we will develop a graphical understanding of the behavior of the Lotka-Volterra model for mutualism by analyzing their isoclines.
Isoclines help us define when the two populations are neither growing nor declining.
The combination of densities of species 1 and species 2 that results in a zero per-capita growth rate for species 1 can be found by setting $\frac{dN_1}{dt}=0$ and solving for $N_1$ and $N_2$.
The same can be done for species 2 by setting $\frac{dN_2}{dt}=0$ and solving for $N_1$ and $N_2$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 3&lt;/strong&gt;: Solve for the species 1 isoclines by setting $\frac{dN_1}{dt}=0$.
Remember to consider both trivial and non-trivial steady states&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 4&lt;/strong&gt;: Solve for the species 2 isoclines by setting $\frac{dN_2}{dt}=0$.
Remember to consider both trivial and non-trivial steady states&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 5&lt;/strong&gt;: By now you have solved for the species 1 and species 2 isoclines individually.
You should have 4 expressions in total: two describing the species 1 equilibrium (one trivial and one non-trivial) and two describing the species 2 equilibrium (one trivial and one non-trivial).
Work in groups to plot the 4 isoclines - you may use a piece of paper or the whiteboard.
Note that for consistency with my slides, the y-axis should represent species 1&amp;rsquo;s density ($N_1$ ) and the x-axis should represent species 2&amp;rsquo;s density ($N_2$), as follows:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://models4data2theory.github.io/images/dynamics/phaseplane_04.png&#34; alt=&#34;PhasePlane&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 6&lt;/strong&gt;: Revisit the different definitions of stability provided at the end of day 1.
Identify which of those definitions are appropriate for characterizing the stability of the L-V model of mutualism.&lt;/p&gt;
&lt;h3 id=&#34;parameter-effects&#34;&gt;Parameter effects&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Understanding&lt;/strong&gt; $\alpha_{12}$ &lt;strong&gt;and&lt;/strong&gt; $\alpha_{21}$ &lt;strong&gt;and mutualism strength&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The strength of mutualism can vary as you shift $\alpha_{12}$ and $\alpha_{21}$ with higher values representing stronger mutualism.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 7&lt;/strong&gt;: Discuss with your group how you expect the strength of mutualism to affect the likelihood of stable coexistence between species.
Do you expect that strong or weak mutualism will allow the persistence of both species?&lt;/p&gt;
&lt;p&gt;Now, we will explore isoclines under different parameter values by first loading the code that contains the model.
If you looking this in the website, you will need first to open and download the following R code.
On Mac, you can just right-click on the hyperlink.
On Windows, you will need to open, copy all, and then save as R code:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://models4data2theory.github.io/courses_Rscripts/LV_2species.R&#34;&gt;Two-species Lotka-Volterra mutualism model&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In class, we will work off the R markdown, which will load the code using source.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 8&lt;/strong&gt;: Test your hypothesis using the &lt;code&gt;lvMutualismInteractive()&lt;/code&gt; function.
Copy and paste the code chunk below in the R console to fix all parameters except $\alpha_{12}$ and $\alpha_{21}$, which you can manipulate.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-{.r,&#34; data-lang=&#34;{.r,&#34;&gt;lvMutualismInteractive(N1_0=10, r1=10.0, K1=100, N2_0=10, r2=10.0, K2=75)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will create an interactive plot where you can manipulate parameters.
Just click on the gear icon on the left-top corner and the manipulator will appear.
By default, the plot that is produced shows the abundance of species 1 and 2 over time.
However, you can also visualize what&amp;rsquo;s called a &amp;ldquo;phase diagram&amp;rdquo; by choosing &amp;ldquo;Phase Space&amp;rdquo; from the drop-down menu at the top of the interactive panel.
While &amp;ldquo;abundance over time&amp;rdquo; plots $N_1$ and $N_2$ against $t$, the &amp;ldquo;Phase Space&amp;rdquo; setting plots $N_1$ against $N_2$.
In this plot, the magenta &amp;lsquo;X&amp;rsquo; represents the starting point of the trajectory and the magenta triangle represents the ending point of the same trajectory shown in the timeseries.
The plot also shows you the location of the $N_1$ and $N_2$ isoclines, the lines where $dN_1/dt$ and $dN_2/dt$ are zero, respectively, which you already solved for.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt;: Run the model with the following $(\alpha_{12},\alpha_{21})$ pairs: $(0.2,0.3)$, $(0.7, 0.6)$, and $(1, 1.2)$.
How does interaction strength affect stability across this range of values?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: if you see a warning in the R Console about DLSODA, do not worry, this is expected with the extreme dynamics observed at high alpha values.&lt;/p&gt;
&lt;h3 id=&#34;obligate-vs-facultative&#34;&gt;Obligate vs Facultative&lt;/h3&gt;
&lt;p&gt;Up until this point, we have only modeled &lt;strong&gt;facultative mutualism&lt;/strong&gt; where species can enjoy mutualistic benefits to grow more than their carrying capacity, but do not rely on them.
other words, in the absence of a mutualist partner, all populations have been able to equilibrate to a positive carrying capacity.
The Lotka-Volterra model for mutualism also allows us to model &lt;strong&gt;obligate mutualism&lt;/strong&gt;, where populations require the benefits of mutualism to maintain their abundances above zero.
We can obtain obligate mutualism in the model by making the carrying capacities $K_1$ or $K_2$ negative.
A negative carrying capacity means that population trajectories will continuously be drawn towards zero, unless the benefits provided by mutualist partners are sufficient to maintain positive abundance.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 9&lt;/strong&gt;: Discuss with your group how you expect facultative or obligate mutualism will affect the possibility of stable coexistence (i.e., persistence of both species).
Which do you think is more likely to facilitate stable coexistence?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 10&lt;/strong&gt;: Reflect as a group on the overarching conclusions about the effect of strong/weak and obligate/facultative mutualism have on stable coexistence, based on the summary figure:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://models4data2theory.github.io/images/dynamics/mutualism_summary.png&#34; alt=&#34;mutualism_summary&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;saturating-benefits&#34;&gt;Saturating benefits&lt;/h2&gt;
&lt;p&gt;Recall that in the L-V model above, the benefit received by each mutualist from their interaction increases linearly with the abundance of their mutualistic partner.
This linear benefit causes the positive feedback loop that drives the abundance of the populations to infinity.
However, we know that mutualistic benefits do not grow forever but they rather saturate (e.g., fixed number of ovules per plant, consumption saturation just like in other consumer-resource interactions, etc.).
We can model that saturation for example by using a Holling type II functional response, which replaces the linear type I functional response exhibited by the model we have used so far, see equations above.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 11&lt;/strong&gt;: Sketch a diagram approximating how isoclines of the L-V model might change with saturation of benefit accrual between both mutualists.&lt;/p&gt;
&lt;h2 id=&#34;multi-species&#34;&gt;Multi-species&lt;/h2&gt;
&lt;p&gt;The code you downloaded in the section above (&lt;code&gt;LV_2species.R&lt;/code&gt;) contains the Lotka-Volterra model of mutualism and the ode solver.
The equations in such source code are:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-{.r,&#34; data-lang=&#34;{.r,&#34;&gt;dNdtFunc = function(t, states, param)
    {
        with(as.list(c(states, param)), 
        {
            dN1dt = r1 * N1 * ((K1-N1+alpha12*N2) / K1)
            dN2dt = r2 * N2 * ((K2-N2+alpha21*N1) / K2)
            list(c(dN1dt, dN2dt))
        })
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can see that the equations are written for each species, and that the effect of each species interaction is written as a term indicating the effect of each species on its mutualistic partner.
For example, the effect of species 2 on the population growth rate of species 1 is $\alpha_{12} N_2$ (written in the code as &lt;code&gt;alpha12 * N2&lt;/code&gt;) on the right side of the equation for $dN1/dt$ (written in the code as &lt;code&gt;dN1dt&lt;/code&gt;).
Imagine how many lines of code and terms per equation you would need for a networks of, for example, 50 species of plants and 100 species of pollinators.
You would need 150 equations (and lines of code) and as many terms per equation as the number of interactions each of those 150 species has, determined by the network.
That is clearly not an efficient way to code and think about the problem, plus an error-prone approach when writing manually each interaction per each equation.&lt;/p&gt;
&lt;p&gt;A much more efficient approach is thinking in matrices (which encode the networks of species interactions) and connect those matrices to the summation notation in equations.
To take this next step, we will use the Lotka-Volterra model of mutualistic networks used by Bascompte et al 2006 (&lt;em&gt;Science&lt;/em&gt;, Vol 312, pp. 431-433).
This model is simply an extension of the L-V model we used above with linear functional responses, with the only difference that the intra-specific competition encoded in the $(1-N_1/K_1)$ is now represented as self-limitation.
There are also minor differences in notation, with subscripts &lt;em&gt;P&lt;/em&gt; and &lt;em&gt;A&lt;/em&gt;, indicating that a variable or parameter corresponds to that of a plant or animal, respectively.
The equations of this network model are:
$$
\frac{dN_i^P}{N_i^Pdt} = r_i^P - s_i^P N_i^P + \sum_{j=1}^{n} \alpha_{ij}^A N_j^A
$$&lt;/p&gt;
&lt;p&gt;$$
\frac{dN_j^A}{N_j^Adt} = r_j^A - s_j^A N_j^A + \sum_{i=1}^{m} \alpha_{ji}^P N_i^P
$$
Note that these equations are written for &lt;em&gt;per-capita&lt;/em&gt; growth rate but you can recover the &lt;em&gt;population&lt;/em&gt; growth rate by multiplying both sides of the equation by the corresponding population size (i.e., $N_i^P$ or $N_j^A$) as
$$
\frac{dN_i^P}{dt} = r_i^P N_i^P - s_i^P (N_i^P)^2 + \sum_{j=1}^{n} \alpha_{ij}^A N_j^A N_i^P
$$
$$
\frac{dN_j^A}{dt} = r_j^A N_j^A - s_j^A (N_j^A)^2 + \sum_{i=1}^{m} \alpha_{ji}^P N_i^P N_j^A
$$&lt;/p&gt;
&lt;p&gt;Now, we need to connect the summations of these equations to the matrix encoding the plant-pollinator network of interest.
For that, we will go back to our toy network we worked on in day 1:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://models4data2theory.github.io/images/dynamics/bipartite_network.png&#34; alt=&#34;bipartite_network&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 12&lt;/strong&gt;: Write the system of 6 differential equations of the Lotka-Volterra model for mutualism that represents this network. To help, the equations of plant species 1 and 3 are
$$
\frac{dN_1^P}{dt} = (r_1^P - s_1^P N_1^P + \alpha_{11}^A N_1^A + \alpha_{12}^A N_2^A + \alpha_{13}^A N_3^A) N_1^P
$$
$$
\frac{dN_3^P}{dt} = (r_3^P - s_3^P N_3^P + \alpha_{31}^A N_1^A) N_3^P
$$
Work on writing the equations for plant species 2 and the equations of the three species of animals.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; We will work together in class to understand the summation and connect it to the network !&lt;/p&gt;
&lt;p&gt;Now that we have understood together the summation and its connection to the plant-pollinator network, we will see how the computer can help us with building the system of differential equations using matrices.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start by saving the matrix representing the toy network&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-{.r,&#34; data-lang=&#34;{.r,&#34;&gt;interactionMatrix = matrix(c(1, 1, 1, 1, 1, 0, 1, 0, 0), 
                           nrow = 3, byrow = TRUE)
print(interactionMatrix)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will now generate a matrix with alphas drawn from a uniform random distribution for all &lt;em&gt;P&lt;/em&gt; x &lt;em&gt;A&lt;/em&gt; combinations for lack of a better parameter choice (i.e. we don&amp;rsquo;t have empirical estimates of mutualism strengths).
For that, we will extract the number of plants and pollinators from the adjacency matrix and use them as input for the function that draws values from random uniform distribution in R (&lt;code&gt;runif()&lt;/code&gt;):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-{.r,&#34; data-lang=&#34;{.r,&#34;&gt;# Get the number of rows (plant species) and columns (animal species) of the matrix encoding the plant-pollinator network (interactionMatrix)
num_plants &amp;lt;- nrow(interactionMatrix)
num_animals &amp;lt;- ncol(interactionMatrix)

# Number of interactions
L=num_plants*num_animals

# Set the mean and variance of the random uniform distribution
mean_alpha &amp;lt;- 0.5
variance &amp;lt;- 0.2

# Generate the 3x3 matrix with values from a uniform random distribution
matrix_alpha &amp;lt;- runif(L, mean_alpha - variance/2, mean_alpha + variance/2)
matrix_alpha &amp;lt;- matrix(matrix_alpha, nrow = num_plants, byrow = TRUE)

# Print the matrix
print(matrix_alpha)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To illustrate how we will use matrix operations to build the multi-species model,
we will start by showing what you obtain when multiplying element-by-element a randomly generated matrix with all possible interaction strengths between plant and animal species (matrix of alphas) with the adjacency matrix that represents the network of plant-pollinator interactions.
That is, we obtain the interaction strengths corresponding to the network we are studying:
$$
\text{alpha matrix} \odot \text{interaction matrix}
$$
$$
=\begin{bmatrix}
0.46 &amp;amp; 0.53 &amp;amp; 0.51 \\
0.58 &amp;amp; 0.51 &amp;amp; 0.53 \\
0.41 &amp;amp; 0.58 &amp;amp; 0.46
\end{bmatrix} \odot
\begin{bmatrix}
1 &amp;amp; 1 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 0 \\
1 &amp;amp; 0 &amp;amp; 0
\end{bmatrix}
$$
$$
=\begin{bmatrix}
0.46 &amp;amp; 0.53 &amp;amp; 0.51 \\
0.58 &amp;amp; 0.51 &amp;amp; 0 \\
0.41 &amp;amp; 0 &amp;amp; 0
\end{bmatrix}
$$
Note that this alpha matrix might not be the one you generated as the code chunk above generate a new random matrix each time.
Its purpose is only to illustrate what happens when you multiply element-by-element two matrices, especially when one has ones and zeroes (i.e., the adjacency matrix)&lt;/p&gt;
&lt;p&gt;The R code that performs such multiplication is&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-{.r,&#34; data-lang=&#34;{.r,&#34;&gt;# Multiplying element-by-element the interaction matrix and the matrix with interaction strengths:
alpha_realized &amp;lt;- interactionMatrix * matrix_alpha

print(&amp;#34;Interaction strengths realized:&amp;#34;)
print(alpha_realized) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will now calculate the sum of mutualistic effects that each animal population provides to each plant population.
For example, such sum for plant species 1 is:
$$
\alpha_{11}^{A} N_1^{A} + \alpha_{12}^{A} N_2^{A} + \alpha_{13}^{A} N_3^{A}
$$
To calculate such contribution to plant growth, we will first randomly generate the abundance of each animal population:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-{.r,&#34; data-lang=&#34;{.r,&#34;&gt;# Set the mean and variance for uniform random distribution
mean_N &amp;lt;- 0.5
var_N &amp;lt;- 0.1

# Draw animal abundances from uniform random distribution
N_A &amp;lt;- runif(num_animals, mean_N - var_N/2, mean_N + var_N/2)

# Ensure N_A is a matrix for proper matrix multiplication (only in R, Matlab allow multiplying matrices and vectors as one does mathmatically)
N_A_matrix &amp;lt;- matrix(N_A, nrow = length(N_A), ncol = 1)

print(&amp;#34;Vector of animal abundances:&amp;#34;)
print(N_A_matrix)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To illustrate what the following code will do mathematically, here is an example of the matrix shown above with the realized alphas multiplying the vector of animal abundances, which gives us the benefits to population growth each plant species gets from their interactions with pollinators:
$$
\begin{bmatrix}
0.46 &amp;amp; 0.53 &amp;amp; 0.51 \\
0.58 &amp;amp; 0.51 &amp;amp; 0 \\
0.41 &amp;amp; 0 &amp;amp; 0
\end{bmatrix}
\times
\begin{bmatrix}
0.52 \\
0.46 \\
0.54
\end{bmatrix}
$$
$$
=\begin{bmatrix}
0.46 \times 0.52 + 0.53 \times 0.46 + 0.51 \times 0.54 \\
0.58 \times 0.52 + 0.51 \times 0.46 + 0 \\
0.41 \times 0.52 + 0 + 0
\end{bmatrix}
$$
$$
=\begin{bmatrix}
0.76 \\
0.54 \\
0.21
\end{bmatrix}
$$&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-{.r,&#34; data-lang=&#34;{.r,&#34;&gt;# Summed effects on plants across the pollinators that visit them
effects_onP&amp;lt;-(interactionMatrix * matrix_alpha) %*% N_A_matrix

print(&amp;#34;Summed effects of pollinators on plants:&amp;#34;)
print(effects_onP)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that we understand the basics, we will generate all the parameters and initial conditions to run the multi-species model:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-{.r,&#34; data-lang=&#34;{.r,&#34;&gt;
# Set the mean and variance for random distribution
mean_r &amp;lt;- 0.3
var_r &amp;lt;- 0.1

mean_s &amp;lt;- 0.2
var_s &amp;lt;- 0.1

mean_N &amp;lt;- 0.5
var_N &amp;lt;- 0.1

# Generate intrinsic growth rates and self-limitations vectors for plants and animals with values from their respective uniform random distributions
rP &amp;lt;- runif(num_plants, mean_r - var_r/2, mean_r + var_r/2)
rA &amp;lt;- runif(num_animals, mean_r - var_r/2, mean_r + var_r/2)
sP &amp;lt;- runif(num_plants, mean_s - var_s/2, mean_s + var_s/2)
sA &amp;lt;- runif(num_animals, mean_s - var_s/2, mean_s + var_s/2)

# Generate initial conditions vectors for plants and animals with values from their respective uniform random distributions
N_P &amp;lt;- runif(num_plants, mean_N - var_N/2, mean_N + var_N/2)
N_A &amp;lt;- runif(num_animals, mean_N - var_N/2, mean_N + var_N/2)

# Ensure N_P and N_A are matrices for proper matrix multiplication (only in R, Matlab allow multiplying matrices and vectors as one does mathmatically)
N_P_matrix &amp;lt;- matrix(N_P, nrow = length(N_P), ncol = 1)
N_A_matrix &amp;lt;- matrix(N_A, nrow = length(N_A), ncol = 1)

# Define the variables for output
variables &amp;lt;- list(
  &amp;#34;Plant intrinsic growth rates:&amp;#34; = rP,
  &amp;#34;Animal intrinsic growth rates:&amp;#34; = rA,
  &amp;#34;Plant self-limitations:&amp;#34; = sP,
  &amp;#34;Animal self-limitations:&amp;#34; = sA,
  &amp;#34;Plant initial abundances:&amp;#34; = N_P_matrix,
  &amp;#34;Animal initial abundances:&amp;#34; = N_A_matrix
)

# Print the variables with spacing
for (variable_name in names(variables)) {
  cat(variable_name, &amp;#34;\n&amp;#34;)
  print(variables[[variable_name]])
  cat(&amp;#34;\n&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, we form the equations and obtain the population growth rate at the initial time step:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-{.r,&#34; data-lang=&#34;{.r,&#34;&gt;# Equations
dPdt &amp;lt;- (rP - sP * N_P_matrix + (matrix_alpha * interactionMatrix) %*% N_A_matrix) * N_P_matrix

dAdt &amp;lt;- (rA - sA * N_A_matrix + (matrix_alpha * interactionMatrix) %*% N_P_matrix) * N_A_matrix

# Printing results
print(&amp;#34;dN_i^P/dt:&amp;#34;)
print(dPdt)

cat(&amp;#34;\n&amp;#34;)

print(&amp;#34;dN_i^A/dt:&amp;#34;)
print(dAdt)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, all together the code to run the multi-species model is:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-{.r,&#34; data-lang=&#34;{.r,&#34;&gt;# Load adjacency matrix:
interactionMatrix = matrix(c(1, 1, 1, 1, 1, 0, 1, 0, 0), nrow = 3, byrow = TRUE)

# Initialize variables
time_steps &amp;lt;- 12
results &amp;lt;- matrix(0, nrow = time_steps, ncol = 2)

# Get the number of rows (plant species) and columns (animal species) of the matrix encoding the plant-pollinator network (interactionMatrix)
num_plants &amp;lt;- nrow(interactionMatrix)
num_animals &amp;lt;- ncol(interactionMatrix)

# Number of interactions
L=num_plants*num_animals


# Set the mean and variance for uniform random distributions
mean_alpha &amp;lt;- 0.5
var_alpha &amp;lt;- 0.2

mean_r &amp;lt;- 0.3
var_r &amp;lt;- 0.1

mean_s &amp;lt;- 0.2
var_s &amp;lt;- 0.1

mean_N &amp;lt;- 0.5
var_N &amp;lt;- 0.1

# Generate the 3x3 matrix with values from a uniform random distribution
matrix_alpha &amp;lt;- runif(L, mean_alpha - var_alpha/2, mean_alpha + var_alpha/2)
matrix_alpha &amp;lt;- matrix(matrix_alpha, nrow = num_plants, byrow = TRUE)

# Generate intrinsic growth rates and self-limitations vectors for plants and animals with values from their respective uniform random distributions
rP &amp;lt;- runif(num_plants, mean_r - var_r/2, mean_r + var_r/2)
rA &amp;lt;- runif(num_animals, mean_r - var_r/2, mean_r + var_r/2)
sP &amp;lt;- runif(num_plants, mean_s - var_s/2, mean_s + var_s/2)
sA &amp;lt;- runif(num_animals, mean_s - var_s/2, mean_s + var_s/2)

# Generate initial conditions vectors for plants and animals with values from their respective uniform random distributions
N_P &amp;lt;- runif(num_plants, mean_N - var_N/2, mean_N + var_N/2)
N_A &amp;lt;- runif(num_animals, mean_N - var_N/2, mean_N + var_N/2)

# Ensure N_P and N_A are matrices for proper matrix multiplication (only in R, Matlab allow multiplying matrices and vectors as one does mathmatically)
N_P_matrix &amp;lt;- matrix(N_P, nrow = length(N_P), ncol = 1)
N_A_matrix &amp;lt;- matrix(N_A, nrow = length(N_A), ncol = 1)

for (i in 1:time_steps) {
  # Calculate dP/dt and dA/dt
  dPdt &amp;lt;- (rP - sP * N_P_matrix + (matrix_alpha * interactionMatrix) %*% N_A_matrix) * N_P_matrix
  dAdt &amp;lt;- (rA - sA * N_A_matrix + (matrix_alpha * interactionMatrix) %*% N_P_matrix) * N_A_matrix
  
  # Update N_P_matrix and N_A_matrix
  N_P_matrix &amp;lt;- N_P_matrix + dPdt
  N_A_matrix &amp;lt;- N_A_matrix + dAdt
  
  # Store the results
  results[i, ] &amp;lt;- c(N_P_matrix[1], N_A_matrix[1])
}

# Print the results
print(results)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Exercise 13&lt;/strong&gt;: Play with the parameters of the model (i.e., the mean of the random distributions) to obtain different results based on what you learned from the model of two species.
Can you obtain different mode behaviors such as populations growing to infinity or extinctions?
You will need to also change the number of time steps to see the different behaviors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 14&lt;/strong&gt;: How do you think the addition of saturating benefits would change the results of this model?
See the work by Okuyama &amp;amp; Holland 2008 (Ecology Letters, 11: 208–216) who modified this model by incorporating a hyperbolic functional response to represent that the beneﬁts to mutualists saturate with the densities of mutualistic species with which they interact.&lt;/p&gt;
&lt;h2 id=&#34;consumer-resource&#34;&gt;Consumer-resource&lt;/h2&gt;
&lt;p&gt;For about 70 years, theoretical research analyzing the population dynamics of mutualisms roughly only assumed Lotka-Volterra-type models (sensu Valdovinos 2019) to conduct their studies (e.g., Kostitzin 1934; Gause and Witt 1935; Vandermeer and Boucher 1978; Wolin and Lawlor 1984; Bascompte et al. 2006; Okuyama and Holland 2008; Bastolla et al. 2009).
Those models represent mutualistic relationships as direct positive effects between species using a (linear or saturating) positive term in the growth equation of each mutualist that depends on the population size of its mutualistic partner.
While this research increased our understanding of the effects of facultative, obligate, linear, and saturating mutualisms on the long-term stability of mutualistic systems, a more sophisticated understanding of their dynamics (e.g., transients) and of phenomena beyond the simplistic assumptions of the Lotka-Volterra-type models was extremely scarce.
A more mechanistic consumer-resource approach to mutualisms was proposed by Holland and colleagues (Holland et al. 2005; Holland and DeAngelis 2010) and further developed by Valdovinos et al. (2013, 2016, 2018).
This approach decomposes the net effects assumed to be always positive by Lotka-Volterra-type models into the biological mechanisms producing those effects, including the gathering of resources and exchange of services.&lt;/p&gt;
&lt;p&gt;The key advance of the consumer-resource model developed by Valdovinos et al. (2013) is separating the dynamics of the plants’ vegetative biomass from the dynamics of the plants’ floral rewards.
This separation allows
(i) tracking the depletion of floral rewards by pollinator consumption,
(ii) evaluating exploitative competition among pollinator species consuming the floral rewards provided by the same plant species, and
(iii) incorporating the capability of pollinators (adaptive foraging) to behaviorally increase their foraging effort on the plant species in their diet with more floral rewards available.
Another advance of this model is incorporating the dilution of conspecific pollen carried by pollinators, which allows tracking competition among plant species for the quality of pollinator visits.&lt;/p&gt;
&lt;p&gt;A conceptual diagram of the model, focused on the consumer-resource part is:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://models4data2theory.github.io/images/dynamics/Valdovinos_et_al_model_diagram.png&#34; alt=&#34;Valdovinos_et_al_model_diagram&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;This model defines the population dynamics (over time &lt;em&gt;t&lt;/em&gt;) of each plant (Eq. 1) and pollinator (Eq. 2) species of the network, as well as the dynamics of floral rewards (Eq. 3) of each plant species, and the foraging effort (Eq. 4) that each pollinator species (per capita) assigns to each plant species as follows:&lt;/p&gt;
&lt;p&gt;$$
\frac{{dp_i}}{{dt}} = \gamma_i \sum_{j \in A_i} e_{ij} \sigma_{ij} V_{ij} - \mu_i^P p_i \quad (Eq. 1)
$$&lt;/p&gt;
&lt;p&gt;$$
\frac{{da_j}}{{dt}} = \sum_{i \in P_j} c_{ij} V_{ij} b_{ij} \frac{{R_i}}{{p_i}} - \mu_j^A a_j \quad (Eq. 2)
$$&lt;/p&gt;
&lt;p&gt;$$
\frac{{dR_i}}{{dt}} = \beta_i p_i - \phi_i R_i - \sum_{j \in A_i} V_{ij} b_{ij} \frac{{R_i}}{{p_i}} \quad (Eq. 3)
$$&lt;/p&gt;
&lt;p&gt;$$
\frac{{d\alpha_{ij}}}{{dt}} = G_j \alpha_{ij} \left( c_{ij} \tau_{ij} b_{ij} R_i - \sum_{k \in P_j} \alpha_{kj} c_{kj} \tau_{kj} b_{kj} R_k \right) \quad (Eq. 4)
$$&lt;/p&gt;
&lt;p&gt;And the biological processes and assumptions of this model are:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://models4data2theory.github.io/images/dynamics/Table1_ValdovinosOikos2023.PNG&#34; alt=&#34;Table 1 from Valdovinos et al 2023, Oikos&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Despite its apparent complexity, this model provides clear and consistent results, which are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Generalist pollinators have more available food (floral rewards) to them than specialist pollinators&lt;/strong&gt;, which results in generalist pollinator species exhibiting much higher abundances than specialist pollinator species, particularly in nested networks and in networks without adaptive foraging (AF, see point 4).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generalist plants receive more visits than their specialist counter-parts&lt;/strong&gt; but this does not necessarily results in generalist plant species having higher abundances than specialist plants because competition for seed recruitment to adults (not pollination) determines the final abundance of plants (see point 6, below).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generalist plants receive much higher quality of visits than specialist plants in highly nested and moderately connected networks (typical of empirical networks) because they receive high-quality of visits by specialist pollinator species&lt;/strong&gt;, which allow generalist plant species to persist.
Conversely, specialist plant species typically go extinct in these networks without adaptive foraging (AF) because they receive very low quality of visits by generalist pollinators carrying very diluted conspecific pollen. This is because generalist pollinators carry high heterospecific pollen loads when they do not exhibit adaptive foraging in highly nested networks.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pollinators with adaptive foraging (AF) assign higher per-capita foraging efforts to specialist plants&lt;/strong&gt; in highly nested and moderately connected networks, because those plants have more rewards available to them (less consumed) than generalist plants that are much more visited.
This re-distribution of foraging efforts causes niche partitioning of floral rewards among pollinator species and of pollination services among plant species, which allows specialist species of plants and pollinators to coexist with their generalist counter-parts.
That is, after this re-distribution of foraging efforts by generalist pollinators from generalist to specialist plants, specialist pollinators have more floral rewards available to them because generalist pollinators are not depleting the rewards of generalist plants.
Similarly, specialist plants persist because they receive much higher quality of visits of generalist pollinator focusing their foraging efforts on specialist plants and, therefore, carry mostly their conspecific pollen.
This niche partitioning is illustrated by the figure below published in Valdovinos et al 2016 (Ecology Letters):&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://models4data2theory.github.io/images/dynamics/Fig1_ValdovinosOikos2016.PNG&#34; alt=&#34;Fig1_ValdovinosOikos2016.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Which Valdovinos et al 2016 also finds for 8 species of bumblebees in RMBL, see panel
(a) for empirical data and panel
(b) for model results showing that pollinators, in a per-capita basis, prefer specialist
(i.e., those visited by one or a few pollinator species) over generalist plants:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://models4data2theory.github.io/images/dynamics/Fig5_ValdovinosOikos2016.PNG&#34; alt=&#34;Fig5_ValdovinosOikos2016&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;Plant species exhibit two stable attractors&lt;/strong&gt;, &lt;strong&gt;they either go to their carrying capacity reduced by inter-specific competition&lt;/strong&gt; &lt;strong&gt;or they go extinct.&lt;/strong&gt;
Plant final abundances when they persist is determined by their intra-specific and inter-specific competition for other resources that are not pollination, which determine seed recruitment to adults.
Whether a plant population goes to one or the other attractor depends on the plant population receiving a minimum of quality of visits from their pollinators, which occurs (or not) during the model transient dynamics. This is in fact a threshold dynamics which is common to all models of obligate mutualisms (Hale &amp;amp; Valdovinos 2021, Ecology &amp;amp; Evolution).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Competition for resources that determine seed recruitment to adults (not pollination) affects the final plant abundance&lt;/strong&gt; when the minimum quality of visits is reached and the plant population persists.
That is, pollination determines whether the plant population persists or not, but not its final abundance when the plant persists. In fact, the plant abundance at equilibrium is $p_i \approx \frac{K_l}{w_i}$ where $K_l = 1 - \sum_{l \neq i} u_l p_l$ , $w_i$ is intra-specific and $u_l$ inter-specific competition for recruitment.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;If the floral rewards of a plant population drop below the R* needed for pollinators to persist, the plant population goes extinct because pollinators stop visiting it.&lt;/strong&gt;
Floral rewards available to pollinators determine whether a plant population attracts fast enough the pollinator foraging efforts during the transient dynamics to meet its minimum quality of visits to persist.
Dropping below R* starts a non-reversible process to plant extinction, which can occur when a plant receives too many low-quality visits that deplete the rewards below R* but do not meet the quality of visits needed for the plant to persist.
This behavior of the model can be seen, for example, when a plant species enters the network with very low abundance, which requires the plant to produce more floral rewards than its neighbors to attract the pollinator foraging effort fast enough to receive high quality of visits.
Generalist plants at low abundance are the ones that most likely would go extinct via this mechanism, especially in overly-connected networks.
An illustration of this behavior can be found in the figure below from Valdovinos et al 2023, which studies plan invasions:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://models4data2theory.github.io/images/dynamics/Fig2_ValdovinosOikos2023.PNG&#34; alt=&#34;Fig2_ValdovinosOikos2023&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;&lt;strong&gt;This R* keeps the meaning given by Tilman but results from an ideal-free-distribution process&lt;/strong&gt;, in which pollinators keep changing their foraging efforts until the rewards of all plant populations reach the same value, R*, after which foraging efforts of pollinators stop changing and the model dynamics cruises to its equilibrium.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;final-thoughts&#34;&gt;Final thoughts&lt;/h2&gt;
&lt;p&gt;We hope that after these three days you have learned something new in terms of empirical and theoretical research in plant-pollinator systems and how to integrate both types of research.
During the first day, we learned the basics of network structure and how to manipulate empirical data to build plant-pollinator networks, and analyze them.
During the second day, we learned about statistical approaches to analyze species interactions which can provide more detailed understanding to our plant-pollinator and network studies.
During the third day, we went back to dynamics studied mathematically from simple and phenomenological models of one species to phenomenological models of networks to a more mechanistic consumer-resource model of plant-pollinator networks.&lt;/p&gt;
&lt;p&gt;We wish you the best in your next scientific steps and that you can integrate some of what you learned in these three days into your research.&lt;/p&gt;
&lt;h2 id=&#34;readings&#34;&gt;Readings&lt;/h2&gt;
&lt;p&gt;Hale, K.R.S., &amp;amp; Valdovinos, F.S. (2021) Ecological theory of mutualism: Qualitative patterns in two-species population models. &lt;em&gt;Ecology and Evolution,&lt;/em&gt; 00, 1-21.&lt;/p&gt;
&lt;p&gt;Okuyama, T., &amp;amp; Holland, J. N. (2008). Network structural properties mediate the stability of mutualistic communities. &lt;em&gt;Ecology letters&lt;/em&gt;, &lt;em&gt;11&lt;/em&gt;(3), 208-216.&lt;/p&gt;
&lt;p&gt;Valdovinos, F.S., Moisset de Espanés, P., Flores J.D, Ramos-Jiliberto, R. (2013) Adaptive foraging allows the maintenance of biodiversity of pollination networks. &lt;em&gt;Oikos&lt;/em&gt; 122: 907-917.&lt;/p&gt;
&lt;p&gt;Valdovinos, F.S., Brosi, B.J., Briggs, H.M., Moisset de Espanés, P., Ramos-Jiliberto, R., Martinez, N.D. (2016). Niche partitioning due to adaptive foraging reverses effects of nestedness and connectance on pollination network stability. &lt;em&gt;Ecology Letters&lt;/em&gt;, 19, 1277-1286.&lt;/p&gt;
&lt;p&gt;Valdovinos, F.S. (2019) Mutualistic Networks: Moving closer to a predictive theory. &lt;em&gt;Ecology Letters&lt;/em&gt;, 22, 1517-1534, &lt;a href=&#34;DOI:10.1111/ele.13279&#34;&gt;DOI:10.1111/ele.13279&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Valdovinos, F.S. &amp;amp; Marsland III, R. (2021) Niche theory for mutualism: A graphical approach to plant-pollinator network dynamics. &lt;em&gt;The American Naturalist&lt;/em&gt;, 197, 393-404.&lt;/p&gt;
&lt;p&gt;Valdovinos, F. S., Dritz, S., &amp;amp; Marsland III, R. (2023). Transient dynamics in plant-pollinator networks: Fewer but higher quality of pollinator visits determines plant invasion success. &lt;em&gt;Oikos&lt;/em&gt;. &lt;a href=&#34;https://doi.org/10.1111/oik.09634&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.1111/oik.09634&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vandermeer, J. H., &amp;amp; Goldberg, D. E. (2013). &lt;em&gt;Population ecology: first principles&lt;/em&gt;. Princeton University Press. pp 225-238.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;This is not just an analogy! In fact, for certain systems we can determine what this landscape (defined by the &lt;em&gt;system potential&lt;/em&gt; $\phi = -\int_{-\infty}^{\infty} \frac{dN}{dt} dN$) actually looks like quantitatively.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;We have only a single eigenvalue because we have only a single variable. Later, for systems with $n$ variables, we will have $n$ eigenvalues.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;What counts as &amp;ldquo;sufficiently small&amp;rdquo; depends on how nonlinear the function is.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
    <item>
      <title>Of Potential Interest</title>
      <link>https://models4data2theory.github.io/courses/potential_use_or_interest/</link>
      <pubDate>Fri, 23 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://models4data2theory.github.io/courses/potential_use_or_interest/</guid>
      <description>&lt;p&gt;Supplementary materials&lt;/p&gt;
&lt;p&gt;$$
\newcommand{\L}{\mathcal{L}}
$$&lt;/p&gt;
&lt;h2 id=&#34;model-fitting&#34;&gt;Model fitting&lt;/h2&gt;
&lt;h3 id=&#34;probability-distributions&#34;&gt;Probability distributions&lt;/h3&gt;
&lt;h4 id=&#34;Prob_mass_dens&#34;&gt;Mass vs. density&lt;/h4&gt;
&lt;p&gt;For discrete probability distributions,
$P(O | \theta)$ is typically referred to as a &lt;em&gt;probability mass function&lt;/em&gt;.
Given the parameter(s) $\theta$, each integer value of an outcome $O$
(i.e. the discrete random variable) has some probability (some &amp;ldquo;mass&amp;rdquo;) of occurring.&lt;/p&gt;
&lt;p&gt;In contrast, for continuous probability distributions,
we instead refer to &lt;em&gt;probability density functions&lt;/em&gt;, $f(O | \theta)$.
That&amp;rsquo;s because the probability of any specific value of a continuous random variable is zero!
Instead, there is only a non-zero probability of the random variable falling &lt;em&gt;within some interval&lt;/em&gt; of values.
The higher the probability density over that interval,
the higher the probability of observing a measurable value from within it.&lt;/p&gt;
&lt;h4 id=&#34;likelihood-functions&#34;&gt;Likelihood functions&lt;/h4&gt;
&lt;p&gt;The distinction between probability mass functions and probability density functions is relevant to the likelihood functions for discrete and continuous random variables.
For discrete variables (as we will focus on in class), the likelihood of the parameter(s) given the data is equal to the probability of the data given the parameter(s),
$$
L(\theta | O) = P(O | \theta).
$$
For continuous variables, we maximize the likelihood of the parameter given the data by finding the parameter that maximizes the probability density function.
That is, we maximize
$$
L(\theta | O) = f(O | \theta).
$$&lt;/p&gt;
&lt;h3 id=&#34;max_lik_math_poisson&#34;&gt;Analytical MLE for Poisson&lt;/h3&gt;
&lt;p&gt;Given $n$ observations (counts) from a process presumed to be well-described by the Poisson, we have that
$$
-\ln \L(\lambda |k)
= -\sum_i^n \ln \left (\frac{\lambda^{k_i} e^{-\lambda}}{k_i!} \right) .
$$
Remembering that logarithms transform multiplicative processes into additive processes,
we can write this as
$$
-\ln \L(\lambda |k)
= -\sum_i^n \left ( \ln ( \lambda^{k_i} ) + \ln (e^{-\lambda} ) - \ln (k_i!)  \right).
$$
Since $\ln x^y = y \ln x$ and $\ln e^x = x$, we can simplify this to
$$
-\ln \L(\lambda |k)  = -\sum_i^n \left ( k_i \ln (\lambda) -\lambda - \ln (k_i!)  \right).
$$
Distributing the summation, we get
$$
-\ln \L(\lambda |k)  = -\sum_i^n \left ( k_i \ln \lambda \right)  + n\lambda + \sum_i^n  \ln (k_i!).
$$
Now take the derivative with respect to $\lambda$, set it equal to zero, and solve for $\lambda$:
$$
\frac{d -\ln \L(\lambda | k)}{d \lambda} = - \frac{1}{\lambda} \sum_i^n k_i + n = 0 \implies \lambda = \frac{\sum_i^n k_i}{n},
$$
which is the mean value of all the $k_i$ counts!&lt;/p&gt;
&lt;p&gt;Our analytically-solved maximum likelihood estimator for $\lambda$, which we will symbolize by $\hat{\lambda}$, is therefore
$$
\hat{\lambda} = \frac{\sum_i^n k_i}{n}.
$$
This is nothing more than a function, think $\hat{\lambda}(k,n)$, to which we provide a vector of observed $k$ counts and their $n$ number (the vector&amp;rsquo;s length) as inputs.&lt;/p&gt;
&lt;h2 id=&#34;dynamics&#34;&gt;Dynamics&lt;/h2&gt;
&lt;h3 id=&#34;building-exponential-growth&#34;&gt;Building exponential growth&lt;/h3&gt;
&lt;p&gt;Population models are focused on rates of births and deaths.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start out by considering a &amp;ldquo;closed&amp;rdquo; population, with no immigration or emigration.&lt;br&gt;
We will set $B$ = births and $D$ = deaths; right now these are terms for the entire population, overall how many births happened and how many deaths happened?&lt;/p&gt;
&lt;p&gt;A simple population growth model can be formulated by stating the obvious, starting out with the number of individuals in a population at a defined time that we will call $t$:
in the &lt;em&gt;next&lt;/em&gt; time period of interest $(t+1)$&amp;mdash;for example, one year later&amp;mdash;the population size $(N_{t+1})$ will be the current population size $(N_t)$ plus the births $(B)$ that occur between time $t$ and time $t+1$, minus the deaths $(D)$ that occur in that time period.&lt;/p&gt;
&lt;p&gt;We can write this model formally as
$$
N_{t+1} = N_t + B - D.
$$&lt;/p&gt;
&lt;p&gt;Thus, if you know the estimated birth and death rates in the coming time period, as well as the current population size, it is easy to calculate what the population size will be for the next time point.&lt;/p&gt;
&lt;p&gt;The equation above is what we might call a &lt;em&gt;difference&lt;/em&gt; equation:
the difference between the population size of our target species at two discrete points in time.
For many species, especially those with highly seasonal life cycles like annual plants, it makes sense to model them  in discrete time.&lt;/p&gt;
&lt;p&gt;At the same time, for species with overlapping generations, especially those that don&amp;rsquo;t have seasonal reproductive patterns, it makes sense instead to model them in continuous time.
It is also mathematically much more tractable to use continuous-time models.
For the rest of our discussion of population dynamics, we will focus on continuous-time models.&lt;/p&gt;
&lt;p&gt;In thinking about continuous-time models, we move from difference equations like the one presented above to &lt;em&gt;differential&lt;/em&gt; equations that are focused on on the &lt;em&gt;change&lt;/em&gt; in population size over some continuous swath of time.
Calculus is well-suited for this and from here on out, we will use calculus notation to think about the differential equations involved in how population size changes over time, designated as: $\frac{dN}{dt}$.
Remember that the $d$ in calculus notation stands for &amp;lsquo;change&amp;rsquo;: how does population size change as time changes?
It can be helpful to think of this as instantaneous change, or change over a very short period of time.&lt;/p&gt;
&lt;p&gt;One important thing to remember is that $\frac{dN}{dt}$ is keeping track of the &lt;em&gt;change&lt;/em&gt; in population size (not the population size itself), but as we solve these equations to keep track of dynamics, if we have a starting population size then we can track population size over time, because we&amp;rsquo;re keeping track of how the population changes.&lt;/p&gt;
&lt;p&gt;In the case of a closed population, the change in population size is driven only by the births and deaths. In other words,&lt;/p&gt;
&lt;p&gt;$$
\frac{dN}{dt} = B - D.
$$&lt;/p&gt;
&lt;p&gt;Typically, however, $B$ and $D$ are not constants.
If they were, you would get a situation where there would be, say, 50 deaths and 52 births, irrespective of if the population is 60 or if the population is 3 billion.
That is obviously quite unrealistic.&lt;/p&gt;
&lt;p&gt;A more appropriate alternative is to instead assume that birth and death are &lt;em&gt;per-capita&lt;/em&gt;
(i.e., per-individual) rates, e.g., every individual has two offspring and a 50% chance of dying each year.
With per-capita birth and death rates, the total number of births and deaths will typically be very different in a small vs. a large population.&lt;/p&gt;
&lt;p&gt;To formalize this, we could call the per-capita birth rate &lt;em&gt;b&lt;/em&gt; (lower-case, in contrast to the value for the entire population, $B$) and the death rate &lt;em&gt;d&lt;/em&gt;.
$b = \frac{B}{N}$ and $d = \frac{D}{N}$ ;
in other words, the per-capita rates are the population-level total rates divided by the population size. As such, $B = bN$ and $D = dN$.
Thus, you could re-state the equation above as
$$
\frac{dN}{dt} = bN - dN.
$$&lt;/p&gt;
&lt;p&gt;For simplicity, population biologists typically combine the birth and death rates into a single per-capita rate of change in the population.
When multiplied by the population size, it tells us how much the population will change in the next time step: if it will go up or down, and by how much.
We call this per capita population growth rate.
While it is the &amp;ldquo;growth&amp;rdquo; rate it is important to note that the per capita growth rate can also be &lt;em&gt;negative&lt;/em&gt;&amp;mdash;individuals can have a higher probability than dying than giving birth in any moment in time, such that the population can be declining.&lt;/p&gt;
&lt;p&gt;Using the equations above, we could derive this per-capita rate of change a few different ways.
A relatively simple way to think about it is to take all of the births $(B)$ and all of the deaths $(D)$ in the population and divide those by the number of individuals in the population:&lt;/p&gt;
&lt;p&gt;$$
\frac{(B-D)}{N} = b - d = r.
$$
Think of $r$ is the &lt;em&gt;net&lt;/em&gt; per capita birth/death rate or the &lt;em&gt;intrinsic&lt;/em&gt; rate of (net) growth.&lt;/p&gt;
&lt;p&gt;We can now use $r$ to formalize the multiplicative model discussed above, which is focused on understanding how population size changes over time (calculus notation)
$$
\frac{dN}{dt} = rN.
$$&lt;/p&gt;
&lt;h3 id=&#34;taylor-series&#34;&gt;Taylor Series&lt;/h3&gt;
&lt;p&gt;We can approximate any infinitely-differentiable function (as most dynamical models in ecology are, and most biology is assumed to be described by) to an arbitrary degree of accuracy near some point along it using a Taylor Series.
A Taylor Series is an infinite sum of terms involving the function&amp;rsquo;s derivatives.&lt;/p&gt;
&lt;p&gt;(For legibility, we will here write $f&amp;rsquo;(N)$ to indicate $\frac{d f(N)}{dN}$, $f&amp;rsquo;&amp;rsquo;(N)$ to indicate $\frac{d^2 f(N)}{dN}$, etc..)&lt;/p&gt;
&lt;p&gt;Specifically, we can express any function $f(N^*+x$) describing a population&amp;rsquo;s response to a perturbation $x$ as&lt;/p&gt;
&lt;p&gt;$$
f(N^{*}+x) = \sum_{i=0}^\infty \frac{f^{(i)}(N^{*})}{i!}x^i
$$
or, writing out the first four terms, as
$$
f(N^{*}+x) = f(N^{*}) + \underbrace{\frac{f&amp;rsquo;(N^{*})}{1!}n_t^1 + \frac{f&amp;rsquo;&amp;rsquo;(N^{*})}{2!} n_t^2 + \frac{f&amp;rsquo;&amp;rsquo;&amp;rsquo;(N^{*}) }{3!}n_t^3 + &amp;hellip;}_{\text{h.o.t.}}
$$
noting that this is an equality, not an approximation, if the sum goes to infinity.&lt;/p&gt;
&lt;p&gt;For (local) stability analysis, we use only the first-order terms to approximate the dynamics of the perturbation, dropping the zeroth term (since $f(N^*)=0$ by definition) and justifying ignoring all &amp;ldquo;higher order terms&amp;rdquo; by assuming the initial magnitude of the perturbation is sufficiently small.&lt;/p&gt;
&lt;p&gt;To demonstrate just how well the Taylor Series approximation works, consider the following fourth-order polynomial as an example of some complex function for $dN/dt$&lt;/p&gt;
&lt;p&gt;$$
f(N) = -1 + 3.24 N + 5.23 N^2 + 2.8 N^3 + 0.38 N^4
$$
shown in black in the figure below.
The red dot represent the point $N^*$ at which we are approximating the function,
the red line represents our first-order approximation,
and the grey lines represent the approximations including successively higher order terms.
For a sufficiently small $x$ the slope alone does a very good job.
Hopefully it&amp;rsquo;s clear from this example that what counts is &amp;ldquo;sufficiently small&amp;rdquo; depends on how nonlinear the function is.&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/potential_use_or_interest_files/figure-html/TaylorExpansion-1.png&#34; width=&#34;480&#34; /&gt;
&lt;h3 id=&#34;2-sp-competition&#34;&gt;2-sp Competition&lt;/h3&gt;
&lt;h4 id=&#34;try-it-out&#34;&gt;Try it out&lt;/h4&gt;
&lt;p&gt;Download &lt;a href=&#34;https://models4data2theory.github.io/courses_Rscripts/Dynamics_2spComp.R&#34;&gt;Dynamics_2spComp.R&lt;/a&gt; to implement the following code. Play around with the parameter values and initial population sizes to see how they affect the dynamics, whether the two species coexist, or whether one species outcompetes the other.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;library&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;deSolve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;model&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;N1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x[1]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;N2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x[2]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;with&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;as.list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dN1dt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a12&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dN2dt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a21&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dN1dt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dN2dt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Time points at which to evaluate&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;seq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;by&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Starting population sizes at t = 0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;xstart&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0.01&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;N2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0.01&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Parameter values&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;parameters&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a12&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;a21&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0.7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;r2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;K1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;K2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Integrate&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;as.data.frame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xstart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;model&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parameters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Plot dynamics over time&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;plot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;ylab&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#39;Popn size&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;xlab&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#39;Time&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;ylim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;lines&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;lty&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;legend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#39;bottomright&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;n&#34;&gt;legend&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N[1]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N[2]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;n&#34;&gt;lty&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;img src=&#34;https://models4data2theory.github.io/courses/potential_use_or_interest_files/figure-html/TwoSppCompModel-1.png&#34; width=&#34;384&#34; /&gt;
&lt;h4 id=&#34;inferences&#34;&gt;Inferences&lt;/h4&gt;
&lt;p&gt;As you might have observed, in the two-species Lotka-Volterra model, the values of each species&amp;rsquo; intrinsic growth rates have no affect on their asymptotic coexistence potential;
they affect only the transient dynamics.
In fact, the &lt;em&gt;quantitative&lt;/em&gt; values of the intraspecific effects (i.e. the carrying capacities) and the interspecific effects don&amp;rsquo;t affect long-term coexistence either, &lt;em&gt;so long as&lt;/em&gt; they satisfy the &lt;em&gt;qualitative&lt;/em&gt; requirement that &lt;em&gt;both species experiences weaker &lt;strong&gt;inter&lt;/strong&gt;specific competition than &lt;strong&gt;intra&lt;/strong&gt;specific competition&lt;/em&gt;.
That is, if&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$1/K_i = a_{ii} &amp;lt; a_{ij}$ for &lt;em&gt;both&lt;/em&gt; species, then they will coexist indefinitely.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Alternatively, if&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;$1/K_i = a_{ii} &amp;gt; a_{ij}$ for $i=1$ but not for $i=2$, then species 1 will outcompete species 2;&lt;/li&gt;
&lt;li&gt;$1/K_i = a_{ii} &amp;gt; a_{ij}$ for $i=2$ but not for $i=1$, then species 2 will outcompete species 1.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;However, if&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;$a_{ii} &amp;gt; a_{ij}$ for &lt;em&gt;both&lt;/em&gt; species, then the outcome depends on the species&amp;rsquo; initial population sizes.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this last scenario where &lt;em&gt;both species experience stronger &lt;strong&gt;inter&lt;/strong&gt;specific competition than &lt;strong&gt;intra&lt;/strong&gt;specific competition&lt;/em&gt; (on a per capita scale), the species that wins is the species that starts with the larger population size. That is, we see a so-called &lt;em&gt;priority effect&lt;/em&gt; between the alternative final states of the system.&lt;/p&gt;
&lt;p&gt;Time-series for all four scenarios are depicted in the left-hand column of the following figures.
(Note that, for simplicity, I&amp;rsquo;ve set $K_1 = K_2 = r_1 = r_2 = 1$.)&lt;/p&gt;
&lt;img src=&#34;https://models4data2theory.github.io/courses/potential_use_or_interest_files/figure-html/TwoSppGraphical-1.png&#34; width=&#34;672&#34; /&gt;
&lt;h4 id=&#34;state-space&#34;&gt;State-space&lt;/h4&gt;
&lt;p&gt;The the right-hand column of the above figure depicts the same dynamics in &lt;em&gt;state-space&lt;/em&gt;, plotting the two state variables (the species&amp;rsquo; population sizes, $N_1$ and $N_2$) against each other rather than against time. The orange point depicts the final state of each of the time series. The diagonal lines in each plot are the so-called &lt;em&gt;isoclines&lt;/em&gt; (a.k.a. &lt;em&gt;nullclines&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Including the trivial equilibrium (not depicted in the figure), we see four possible steady states from the simulations: ${N_1^&lt;em&gt;, N_2^&lt;/em&gt;} =  {0, 0},  {N_1, 0},   {0, N_2}, {N_1, N_2}$ Notice that all of the non-trivial steady states are located on one or both isoclines. That&amp;rsquo;s because each isocline represents the solution to $f_i =\frac{dN_i}{dt}=0$ for one of the species. Where the isoclines intersect we have that both $\frac{dN_i}{dt}=0$ and $\frac{dN_j}{dt}=0$. More specifically, each isocline represents $N_i^&lt;em&gt;$ as a function of $N_j$:
$$
N_1^&lt;/em&gt; = K_1 - a_{12} N_2 \quad \text{and} \quad N_2^* = K_2 - a_{21}N_1
$$
(See next section for the algebra.)&lt;/p&gt;
&lt;p&gt;The relative positioning of the isoclines &amp;ndash; whether and how they intersect &amp;ndash; gives us graphical insight into whether each of the steady states is stable or unstable. For a given fixed valued of $N_j$, perturbations to $N_i$ that cause $N_i$ to go &lt;em&gt;above&lt;/em&gt; species $i$&amp;rsquo;s isocline $N_i^&lt;em&gt;$ will cause $\frac{dN_i}{dt} &amp;lt; 0$ and $N_i$ will &lt;em&gt;decline&lt;/em&gt; back to $N_i^&lt;/em&gt;$. Conversely, perturbations to $N_i$ that cause $N_i$ to go &lt;em&gt;below&lt;/em&gt; species $i$&amp;rsquo;s isocline $N_i^&lt;em&gt;$ will cause $\frac{dN_i}{dt} &amp;gt; 0$ and $N_i$ will &lt;em&gt;increase&lt;/em&gt; back to $N_i^&lt;/em&gt;$.&lt;/p&gt;
&lt;h4 id=&#34;isoclines&#34;&gt;Isoclines&lt;/h4&gt;
&lt;p&gt;To solve for the isoclines of the two-species Lotka-Volterra competition model.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1:&lt;/strong&gt; Set
$$
f_i = \frac{dN_i}{dt} = 0
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 2:&lt;/strong&gt; Solve for $N_i^&lt;em&gt;$ as a function of $N_j$:
$$
r_i N_i \left ( 1- \frac{N_i}{K_i} -  \frac{a_{ij} N_j}{K_i} \right)  =0
$$
$$
r_i N_i - \frac{r_i N_i N_i}{K_i} - \frac{ r_i a_{ij} N_i N_j}{K_i}  =0
$$
$$
r_i N_i K_i  = r_i N_i N_i + r_i a_{ij} N_i N_j
$$
$$
K_i  = N_i + a_{ij} N_j
$$
$$
N_i^&lt;/em&gt;  = K_i - a_{ij} N_j
$$&lt;/p&gt;
&lt;h3 id=&#34;2d-stability&#34;&gt;2D stability&lt;/h3&gt;
&lt;p&gt;To evaluate the stability of the 2-dimensional steady state ${N_1^&lt;em&gt;, N_2^&lt;/em&gt;}$ will extend the formal &amp;ldquo;linear stability analysis&amp;rdquo; that we applied to the 1-dimensional logistic model (#1Dstability).
In essence, our criterion for stability will be that $f_i^&amp;rsquo;(N_i^&lt;em&gt;, N_j^&lt;/em&gt;) &amp;lt; 0$ for both species, which we will determine using the system&amp;rsquo;s (two) eigenvalues.
Because we&amp;rsquo;re now considering 2 dimensions, we have to consider not only how $N_i$ responds to a perturbation $x_i$ and how $N_j$ responds to a perturbation $x_j$, but also how $N_i$ responds to $x_j$ and how $N_j$ responds to $x_i$.
We&amp;rsquo;ll therefore be considering a 2x2 matrix of responses.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;ll again be re-framing to consider not the dynamics of the abundances $N_i$ and $N_j$ but will instead consider the dynamics of the perturbations $x_i$ and $x_j$. That is, we write
$$
N_1 = N_1^* + x_1 \quad \text{ and } \quad N_2 = N_2^* + x_2
$$
such that
$$
\frac{dN_1}{dt}=\frac{d(N_1^{*} + x_1)}{dt} = f_1(N_1^{*} + x_1, N_2^{*}+x_2)
$$
and
$$
\frac{dN_2}{dt}=\frac{d(N_2^* + x_2)}{dt} = f_2(N_1^* + x_1, N_2^&lt;em&gt;+x_2)
$$
Because $N_1^&lt;/em&gt;$ and $N_2^*$ are constants, the rates of change of $x_1$ and $x_2$ will be the same, thus&lt;/p&gt;
&lt;p&gt;$$
\frac{d x_1}{dt} = f_1(N_1^{*} + x_1, N_2^{*}+x_2) \quad \text{ and } \quad \frac{d x_2}{dt} = f_2(N_1^{*} + x_1, N_2^{*}+x_2)
$$
The functions $f_1$ and $f_2$ could be very complicated, but we can again approximate them with a Taylor expansion, this time in two dimensions using partial derivatives with respect to each species.
That is, we approximate $f_1$ by
$$
f_1(N_1^{*} + x_1, N_2^{*}+x_2) \approx
$$
$$
f_1(N_1^{*}, N_2^{*}) + \frac{\partial f_1(N_1^{*}, N_2^{*})}{\partial N_1} \cdot x_1 + \frac{\partial f_1(N_1^{*}, N_2^{*})}{\partial N_2} \cdot x_2 + h.o.t.
$$
and approximate $f_2$ by
$$
f_2(N_1^{*} + x_1, N_2^{*}+x_2) \approx
$$
$$ f_2(N_1^{*}, N_2^{*}) + \frac{\partial f_2(N_1^{*}, N_2^{*})}{\partial N_1} \cdot x_1 + \frac{\partial f_2(N_1^{*}, N_2^{*})}{\partial N_2} \cdot x_2 + h.o.t.
$$
Since $f_1(N_1^{*}, N_2^{*}) = f_2(N_1^{*}, N_2^{*}) = 0$ by definition, and ignoring all higher order terms (i.e. assuming $x_1$ and $x_2$ are sufficiently small) we arrive at
$$
f_1(N_1^{*} + x_1, N_2^{*}+x_2) \approx \frac{\partial f_1(N_1^{*}, N_2^{*})}{\partial N_1} \cdot x_1 + \frac{\partial f_1(N_1^{*}, N_2^{*})}{\partial N_2} \cdot x_2
$$
and
$$
f_2(N_1^{*} + x_1, N_2^{*}+x_2) \approx \frac{\partial f_2(N_1^{*}, N_2^{*})}{\partial N_1} \cdot x_1 + \frac{\partial f_2(N_1^{*}, N_2^{*})}{\partial N_2} \cdot x_2  .
$$&lt;/p&gt;
&lt;h4 id=&#34;community-matrix&#34;&gt;Community matrix&lt;/h4&gt;
&lt;p&gt;To make our notation more compact, we can substitute
$$
A_{ij} = \frac{\partial f_i(N_1^{*}, N_2^{*})}{\partial N_j}
$$
for $i \in {1,2}$ and $j \in {1,2}$.&lt;/p&gt;
&lt;p&gt;More explicitly, let
$$
A_{11} = \frac{\partial f_1(N_1^{*}, N_2^{*})}{\partial N_1},
$$
$$
A_{12} = \frac{\partial f_1(N_1^{*}, N_2^{*})}{\partial N_2},
$$
$$
A_{22} = \frac{\partial f_2(N_1^{*}, N_2^{*})}{\partial N_2},
$$
and
$$
A_{21} = \frac{\partial f_2(N_1^{*}, N_2^{*})}{\partial N_1}
$$
We can therefore write our equations for $\frac{d x_1}{dt}$ and $\frac{d x_2}{dt}$ as
$$
\frac{d x_1}{dt} = f_1(N_1^{*} + x_1, N_2^{*}+x_2) \approx A_{11} \cdot x_1 + A_{12} \cdot x_2
$$
and
$$
\frac{d x_2}{dt} = f_2(N_1^{*} + x_1, N_2^{*}+x_2) \approx A_{21} \cdot x_1 + A_{22} \cdot x_2.
$$
We can then represent the two equations even more compactly in matrix form as
$$
\begin{bmatrix}&lt;br&gt;
\frac{dx_1}{dt} \\
\frac{dx_2}{dt}
\end{bmatrix}
\approx
\begin{bmatrix}
A_{11} &amp;amp; A_{12} \\
A_{21} &amp;amp; A_{22}
\end{bmatrix}
\cdot
\begin{bmatrix}
x_1 \\
x_2
\end{bmatrix}
$$
or even more compactly with
$$
\frac{d \textbf{x}}{dt} = \textbf{A} \textbf{x}
$$
where column vector
$$
\textbf{x} =
\begin{bmatrix}&lt;br&gt;
\frac{dx_1}{dt} \\
\frac{dx_2}{dt}
\end{bmatrix}
$$
and matrix
$$
\textbf{A} = \begin{bmatrix}
A_{11} &amp;amp; A_{12} \\
A_{21} &amp;amp; A_{22}
\end{bmatrix}.
$$&lt;/p&gt;
&lt;p&gt;The matrix $\textbf{A}$ is commonly referred to as the &lt;em&gt;Community Matrix&lt;/em&gt;.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;
Each element may be interpreted as an interaction strength in that it describes how a small perturbation to the species in column $j$ affects the population growth rate of the species in row $i$ (with the abundance of all other species in an $n&amp;gt;2$ species system held constant).&lt;/p&gt;
&lt;h4 id=&#34;eigenvalues&#34;&gt;Eigenvalues&lt;/h4&gt;
&lt;p&gt;The eigenvalues of the Community Matrix hold all the information we need to determine the local stability of the steady state.&lt;/p&gt;
&lt;p&gt;Eigenvalues can have both &lt;em&gt;real&lt;/em&gt; and so-called &lt;em&gt;imaginary&lt;/em&gt; parts.
The real parts tell us about the local stability. The imaginary parts tell us about the periodicity of the dynamics.&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;Criterion&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Eigenvalues&lt;/strong&gt; ($\lambda_i$)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(1)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$Re(\lambda_i)&amp;lt; 0$ for all $i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(2)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$Re(\lambda_i)&amp;gt; 0$ for all $i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(3)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$Re(\lambda_i) = 0$ for all $i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(4)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$Re(\lambda_i)&amp;lt; 0$ for some $i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$(i)$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$Im(\lambda_i) = 0$ for all $i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$(ii)$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$Im(\lambda_i) \neq 0$ for some $i$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/center&gt;
&lt;p&gt;Criterion 1 reflects the situation where the steady state is at the bottom of a bowl; all perturbations decays exponentially towards zero, so we have stable coexistence.&lt;/p&gt;
&lt;p&gt;Criterion 2 reflects the situation where the steady state is at the top of an inverted bowl; all perturbations grow exponentially, so coexistence is unstable.&lt;/p&gt;
&lt;p&gt;Criterion 3 reflects a completely flat system potential surface; any perturbation will persist at its initial value, so coexistence is neutrally stable.&lt;/p&gt;
&lt;p&gt;Criterion 4 reflects (potential) stability in some dimensions (for some species) but not all, so coexistence is unstable.&lt;/p&gt;
&lt;p&gt;Criteria i and ii tells us about how the perturbation decays or grows (e.g., decaying monotonically or with decaying oscillations).&lt;/p&gt;
&lt;p&gt;Most of the time we don&amp;rsquo;t care about whether oscillations occur, only whether coexistence is stable or not. For that we only care about the real parts of the eigenvalues.
In fact, note that Criterion 1 is also satisfied by having the &lt;em&gt;dominant eigenvalue&lt;/em&gt; (the maximum and most positive eigenvalue) be negative.&lt;/p&gt;
&lt;h4 id=&#34;try-it&#34;&gt;Try it&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;R&lt;/strong&gt; can do only very limited manipulation of symbolic expressions, but it does have the &lt;code&gt;eigen()&lt;/code&gt; function to determine the eigenvalues of a numeric matrix.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Specify the community matrix&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;matrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;-1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;-0.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;m&#34;&gt;-0.6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;-1&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;. &lt;/span&gt; &lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;byrow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;TRUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;nrow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Determine its eigenvalues&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;eigs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;eigen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;values&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;##      [,1] [,2]
## [1,] -1.0 -0.5
## [2,] -0.6 -1.0
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eigs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## [1] -1.5477226 -0.4522774
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-r&#34; data-lang=&#34;r&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eigs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## [1] -0.4522774
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;session-info&#34;&gt;Session Info&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## R version 4.4.1 (2024-06-14)
## Platform: aarch64-apple-darwin20
## Running under: macOS Sonoma 14.5
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib 
## LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## time zone: America/Los_Angeles
## tzcode source: internal
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] deSolve_1.40
## 
## loaded via a namespace (and not attached):
##  [1] digest_0.6.37     R6_2.5.1          bookdown_0.40     fastmap_1.2.0    
##  [5] xfun_0.47         blogdown_1.19     cachem_1.1.0      knitr_1.48       
##  [9] htmltools_0.5.8.1 rmarkdown_2.28    lifecycle_1.0.4   cli_3.6.3        
## [13] sass_0.4.9        jquerylib_0.1.4   compiler_4.4.1    highr_0.11       
## [17] rstudioapi_0.16.0 tools_4.4.1       evaluate_0.24.0   bslib_0.8.0      
## [21] yaml_2.3.10       jsonlite_1.8.8    rlang_1.1.4
&lt;/code&gt;&lt;/pre&gt;&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;When matrix $\textbf{A}$ is not evaluated at a steady state it is formally referred to as a Jacobian matrix.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://models4data2theory.github.io/admin/config.yml</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://models4data2theory.github.io/admin/config.yml</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://models4data2theory.github.io/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://models4data2theory.github.io/contact/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
