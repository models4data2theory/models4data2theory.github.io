---
title: "Model Fitting"
output:
  html_document:
    toc: true
    theme: united
---

# Part 1 - Basics
Our first objective is to use maximum likelihood to estimate $\lambda$ of a Poisson given hypothetical count data.

First, we generate some fake data.

Specify the actual true value of $\lambda$ with which to simulate counts and the desired sample size $n$.
```{r}
lambda.true <- 30.333 
n <- 2
```

Generate $n$ random visitation counts $k$.
```{r}
k <- rpois(n, lambda.true )
```

Visualize the counts.
```{r}
hist(k, breaks = 0:max(k))
abline(v = lambda.true,
       lwd = 2,
       col = 'red')
```

Now, treating these fake data as real data drawn from a Poisson distribution with an unknown $\lambda$, we use maximum likelihood to obtain an estimate for $\lambda$.

Define negative log likelihood function.
```{r}
nlL.pois <- function(lambda){
  -sum(dpois(k, lambda, log = TRUE))
}
```

Provide an initial guess for $\lambda$.
```{r}
init.par <- list(lambda = 2)
```

Fit the model to the data (suppressing the `optim()` 1D warning.)
```{r}
suppressWarnings(
  fit <- optim(init.par, nlL.pois)
)

print(fit)
```


Add the estimated $\lambda$ to the data visualization.
```{r}
hist(k, breaks = 0:max(k))
abline(v = lambda.true,
       lwd = 2,
       col = 'red')
abline(v = fit$par,
       lwd = 2,
       col = 'blue')
```

# Part 2 - Your first challenge

Your challenge is to fit the binomial model to real data on fertilization success rates
(i.e. counts of total and fertilized ovules).


Import the GoogleSheet directly
```{r}
dat <- read.csv('https://docs.google.com/spreadsheets/d/e/2PACX-1vTyyqthYKtedUdgRCOE37ec-oA4TzY6Mq8glR9bWr8ORhGQjWZlkeIuM5AgdGa8-zHE9pJma8C3n4_n/pub?gid=0&single=true&output=csv')
```
If that doesn't work, then paste the above link into a browser to save the GoogleSheet csv file to your desktop.  Then either

Import downloaded csv file using either a user prompt...
```{r}
# dat <- read.csv(file.choose())
```

... or by specifying its location using, for example,
```{r}
#  dat.loc <- 'MyDesktopLocation'
#  dat <- read.csv(paste0(dat.loc, 'Delphinium_fertilization_success - Sheet1.csv'))
```

### Data preparation
Remove rows with no data.
```{r}
dat <- subset(dat, !is.na(dat$Total.count) 
                 & !is.na(dat$Fertilized.count))
```

Extract vectors of Total.counts (draws) and Fertilized.counts (successes)
```{r}
N <- dat$Total.count
k <- dat$Fertilized.count
```

### Your to do list
1) Define the negative log-likelihood function for binomial model.
2) Provide initial guess for binomial 'probability'.
3) Fit the model.
4) Overlay the parameter estimate on a histogram of the *proportion* of fertilized ovules.

*"Answer key" at the bottom.*

# Part 3a - Fitting "mechanistic" models
Fitting models f1-f3 to a randomly-generated visitation rate dataset.

Generate fake data
```{r}
# set.seed(1) # (if desired for reproducibility)

n <- 40 # Sample size
P <- runif(n, 0, 100) # Plant densities

a <- 3.333 # True value of 'a'
h <- 0.025 # True value of 'h'

k <- NULL # Visitation counts
for(i in 1:n){
  # Generate a 'k' for each 'P' assuming the truth 
  # is Type 2 (model f2)
  k[i] <- rpois(1, a * P[i] / (1 + a * h * P[i]) )
}


plot(P, k,
     xlim = c(0, max(P)),
     ylim = c(0, max(k)),
     xlab = 'Plant density (P)',
     ylab = 'Visitation count (k)')
```

Define negative-log likelihood function for the Type I model (f1) and fit it.
```{r}
nlL.pois.f1 <- function(par){
  a <- par['a']
  -sum(dpois(k, a * P, log = TRUE))
}

fit.f1 <- optim(par = list(a = 1),
                fn = nlL.pois.f1)
print(fit.f1)
```

Define a function to plot the fitted model.
```{r}
plot.f1 <- function(x, fit){
  a <- fit$par['a']
  return(a * x)
}

plot(P, k,
     xlim = c(0, max(P)),
     ylim = c(0, max(k)),
     xlab = 'Plant density (P)',
     ylab = 'Visitation count (k)')

curve(plot.f1(x, fit.f1), 
      add = TRUE,
      lwd = 2)
```

# Part 3b - Your second challenge

## Your to do list
1) Fit the Type II (f2) and Type III (f3) models 
2) Compare all three models in terms of their
  2a) parameter MLEs
  2b) likelihoods (i.e. compare how well they fit the data).
3) Write functions to calculate AIC and BIC and compare the performance of all three models.

*"Answer key" below*


# "Answer keys"

## Part 2

1) Define the negative log-likelihood function for binomial

```
nlL.binom <- function(prob){
  -sum(dbinom(k, N, prob, log = TRUE))
}
```


2) Provide initial guess for binomial 'probability'
```
init.par <- list(prob = 0.3)
```

3) Fit the model (suppressing the `optim()` 1D warning)
```
suppressWarnings(
  fit <- optim(init.par, nlL.binom)
)

print(fit)
```


4) Overlay the parameter estimate on histogram of the *proportion* of fertilized ovules
```
hist(k/N,
     breaks = 20,
     xlim = c(0, 1))

abline(v = fit$par,
       lwd = 2)
```

## Part 3

#### Type II (model f2)
```
nlL.pois.f2 <- function(par){
  a <- par['a']
  h <- par['h']
  -sum(dpois(k, a * P / (1 + a * h * P), log = TRUE))
}

fit.f2 <- optim(par = list(a = fit.f1$par['a'] * 5, 
                           h = 1/50),
                fn = nlL.pois.f2)
print(fit.f2)

plot.f2 <- function(x, fit){
  a <- fit$par['a']
  h <- fit$par['h']
  return(a * x / (1 + a * h * x))
}
curve(plot.f2(x, fit.f2), 
      add = TRUE,
      lwd = 3,
      col = 'blue')
```


#### Type III (model f3)
```
nlL.pois.f3 <- function(par){
  a <- par['a']
  h <- par['h']
  theta <- par['theta']
  -sum(dpois(k, a * P^theta / (1 + a * h * P^theta), log = TRUE))
}

fit.f3 <- optim(par = list(a = fit.f2$par['a'], 
                           h = fit.f2$par['h'], 
                           theta = 1),
                fn = nlL.pois.f3)
print(fit.f3)

plot.f3 <- function(x, fit){
  a <- fit$par['a']
  h <- fit$par['h']
  theta <- fit$par['theta']
  return(a * x^theta / (1 + a * h * x^theta))
}
curve(plot.f3(x, fit.f3), 
      add = TRUE,
      lwd = 1.5,
      col = 'orange')
```

```
legend(
  'bottomright',
  c('Type I', 'Type II', 'Type III'),
  col = c('black','blue','orange'),
  lwd = 2,
  bty = 'n'
)
```



#### Parameter estimates
```
print(c(a = a, h = h, theta = 1))
fit.f1$par
fit.f2$par
fit.f3$par
```

#### Negative log-Likelihoods
```
fit.f1$value
fit.f2$value
fit.f3$value
```


#### AIC and BIC
```
AIC <- function(fit){
  nlL <- fit$value
  p <- length(fit$par)
  return( 2 * nlL + 2 * p )
}

BIC <- function(fit, n){
  nlL <- fit$value
  p <- length(fit$par)
  return( 2 * nlL + log(n) * p )
}


c(AIC.f1 = AIC(fit.f1),
  AIC.f2 = AIC(fit.f2),
  AIC.f3 = AIC(fit.f3))

c(BIC.f1 = BIC(fit.f1, length(k)), 
  BIC.f2 = BIC(fit.f2, length(k)),
  BIC.f3 = BIC(fit.f3, length(k)))
```

# Extra

The following is provided simply for you to have the final code of the lesson plan.  You don't need to use it for the above in-class exercise.

```
library(bbmle)
 
# bbmle needs the negative log likelihood function formulated differently
nlL.pois.f1.bbmle <- function(a){
  -sum(dpois(k, a * P, log = TRUE))
}

fit <- mle2(nlL.pois.f1.bbmle, 
            start = list(a = 0.2))
print(fit)
confint(fit)
```